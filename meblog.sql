/*
Navicat MySQL Data Transfer

Source Server         : xiaobai
Source Server Version : 80016
Source Host           : localhost:3306
Source Database       : meblog

Target Server Type    : MYSQL
Target Server Version : 80016
File Encoding         : 65001

Date: 2020-06-28 00:05:35
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `appreciation` bit(1) NOT NULL COMMENT '赞赏是否开启',
  `commentabled` bit(1) NOT NULL COMMENT '评论是否开启',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `create_time` datetime DEFAULT NULL,
  `first_picture` varchar(255) DEFAULT NULL,
  `flag` varchar(255) DEFAULT NULL,
  `publicshed` bit(1) NOT NULL COMMENT '是否发布',
  `recommend` bit(1) NOT NULL COMMENT '是否推荐',
  `shar_statement` bit(1) NOT NULL,
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `views` int(11) DEFAULT NULL,
  `type_id` bigint(20) DEFAULT NULL,
  `user_id` bigint(20) DEFAULT NULL,
  `tag_ids` varchar(255) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK292449gwg5yf7ocdlmswv9w4j` (`type_id`),
  KEY `FK8ky5rrsxh01nkhctmo7d48p82` (`user_id`),
  CONSTRAINT `t_blog_ibfk_1` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `t_blog_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=1276785781947498497 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('1271646382477803520', '', '', '###   事务\r\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\r\n\r\n**事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\r\n事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\r\n一个事务从开始到执行会经历以下三个阶段：**\r\n\r\n开始事务。\r\n命令入队。\r\n执行事务。\r\n\r\n[redis中文网站](https://www.redis.net.cn/order/) 方便查询命令\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601215659551.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n```java\r\nMySQL 的ACID\r\n原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在\r\n	  执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\r\n\r\n一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，\r\n	   这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。\r\n\r\n隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执\r\n	   行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、\r\n	   可重复读（repeatable read）和串行化（Serializable）。\r\n\r\n持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\r\n```\r\n==Redis单条命令保存原子性的，但是事务不保证原子性==\r\n\r\n一次性，顺序性，排它性\r\n\r\n**redis事务没有隔离级别的概念。**\r\n**所有命令在事务中，并没有直接执行，只有在发起执行命令的时候才会执行，Exec**\r\n\r\nredis的事务\r\n\r\n- 开启事务\r\n- 命令入队\r\n- 执行事务\r\n\r\n在传统的关系型数据组中，只要有任意一条指令失败，则整个事务会被撤销回滚，而在redsi中，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做，因此得出redis事务的执行并。\r\n　　**Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。**\r\n\r\n```java\r\n锁：redis可以实现乐观锁，wathc\r\n```\r\n**正常执行事务**\r\n```bash\r\n127.0.0.1:6379> multi #开启事务\r\nOK\r\n127.0.0.1:6379> set k1 v1\r\nQUEUED\r\n127.0.0.1:6379> set k2 v2\r\nQUEUED\r\n127.0.0.1:6379> get k2\r\nQUEUED\r\n127.0.0.1:6379> exec 执行事务\r\n1) OK\r\n2) OK\r\n3) \"v2\"\r\n127.0.0.1:6379>\r\n\r\n```\r\n事务都是一次的，如果需要再次开启事务即可\r\n\r\n**放弃事务**\r\n\r\n```bash\r\n127.0.0.1:6379> MULTI #开启事务\r\nOK\r\n127.0.0.1:6379> set k3 v3\r\nQUEUED\r\n127.0.0.1:6379> set k4 v4\r\nQUEUED\r\n127.0.0.1:6379> DISCARD # 放弃事务\r\nOK\r\n127.0.0.1:6379> get k3\r\n(nil)\r\n\r\n```\r\n**编译型异常**\r\n\r\n代码有问题，命令有错，事务中所有的命令都不会被执行。\r\n\r\n```bash\r\n127.0.0.1:6379> MULTI\r\nOK\r\n127.0.0.1:6379> set k1 k2\r\nQUEUED\r\n127.0.0.1:6379> set k2 k3\r\nQUEUED\r\n127.0.0.1:6379> GETSET k3\r\n(error) ERR wrong number of arguments for \'getset\' command\r\n127.0.0.1:6379> set k4 k4\r\nQUEUED\r\n127.0.0.1:6379> set k5 k5\r\nQUEUED\r\n127.0.0.1:6379> EXEC\r\n(error) EXECABORT Transaction discarded because of previous errors.\r\n127.0.0.1:6379> get k1\r\n(nil)\r\n\r\n```\r\n\r\n**运行时异常**\r\n\r\n（1/0） 如果事务队列中存在语法性错误，那么执行命令的时候，其它命令式可以正常执行的\r\n\r\n```bash\r\n127.0.0.1:6379> keys *\r\n(empty list or set)\r\n127.0.0.1:6379> set k1 v1\r\nOK\r\n127.0.0.1:6379> MULTI\r\nOK\r\n127.0.0.1:6379> incr k1 # 自增1 命令保错 但是其它依旧执行成功\r\nQUEUED\r\n127.0.0.1:6379> set k2 v2\r\nQUEUED\r\n127.0.0.1:6379> set k3 v3\r\nQUEUED\r\n127.0.0.1:6379> EXEC\r\n1) (error) ERR value is not an integer or out of range\r\n2) OK\r\n3) OK\r\n127.0.0.1:6379> get k2\r\n\"v2\"\r\n127.0.0.1:6379> get k3\r\n\"v3\"\r\n127.0.0.1:6379>\r\n```\r\n**监控**\r\n\r\n悲观锁：\r\n\r\n - 很悲观，什么时候都会出问题，无论做什么都会加锁。\r\n \r\n 乐观锁：\r\n \r\n - 很乐观，认为什么时候都不会出问题，所有不会上锁，更新数据的时候去判断一下，在此期间是否有人修改过这个数据，\r\n - MySQL 获取version\r\n - 更新的时候比较version\r\n\r\n**redis测监视测试**\r\n\r\n正常执行成功！\r\n\r\n```bash\r\n127.0.0.1:6379> set money 100 \r\nOK\r\n127.0.0.1:6379>\r\n127.0.0.1:6379> set out 0\r\nOK\r\n127.0.0.1:6379> watch money #监视一个key 如果在事务执行之前key 被其他命令所改动 那么事务将被打断 监视 money 的值是100 下面执行之前会提前获取money的值 做比较\r\nOK\r\n127.0.0.1:6379> MULTI #事务正常结束 数据期间没有发送变动 这个时候就正常执行成功！\r\nOK\r\n127.0.0.1:6379> decrby money 20\r\nQUEUED\r\n127.0.0.1:6379> incrby out 20\r\nQUEUED\r\n127.0.0.1:6379> EXEC\r\n1) (integer) 80\r\n2) (integer) 20\r\n127.0.0.1:6379>\r\n\r\n```\r\n不正常执行\r\n\r\n```bash\r\n#客户端2\r\n\r\n127.0.0.1:6379> WATCH money\r\nOK\r\n127.0.0.1:6379> MULTI\r\nOK\r\n127.0.0.1:6379> decrby money 10\r\nQUEUED\r\n127.0.0.1:6379> incrby out 10\r\nQUEUED\r\n127.0.0.1:6379> EXEC \r\n# 执行之前 另外一个线程修改money的值 比对监视的值是否发生了变化，\r\n# 如果没有变化，那么执行成，如果变化就执行失败\r\n(nil)\r\n127.0.0.1:6379>\r\n\r\n#客户端2\r\n127.0.0.1:6379> WATCH money\r\nOK\r\n127.0.0.1:6379> get money\r\n\"80\"\r\n127.0.0.1:6379> getset money 100\r\n\"80\"\r\n127.0.0.1:6379> get money\r\n\"100\"\r\n127.0.0.1:6379>\r\n\r\n# 在客户端1 监视money的值 开启事务 修改money的值 \r\n# 在客户端2监视money的值 并且修改money的值\r\n# 在客户端1中提交事务 发现为nil 这是因为在开启事务和执行事务之中money的值被修改了\r\n# Redis Watch 命令 - 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。\r\n# Watch 实现乐观锁\r\n```\r\n**解决办法**\r\n\r\n```bash\r\n# 如果发现事务执行失败，先解锁\r\n# 获取最新的值 再次监视 （select vsersion）\r\n# 比对监视的值是否发生了变化，如果没有变化，那么执行成，如果变化就执行失败\r\n127.0.0.1:6379> set a 1\r\nOK\r\n127.0.0.1:6379> set b 1\r\nOK\r\n127.0.0.1:6379> WATCH a b\r\nOK\r\n127.0.0.1:6379> MULTI\r\nOK\r\n127.0.0.1:6379> set a 2\r\nQUEUED\r\n127.0.0.1:6379> set b 2\r\nQUEUED\r\n127.0.0.1:6379> EXEC\r\n(nil)\r\n127.0.0.1:6379> UNWATCH\r\nOK\r\n127.0.0.1:6379> WATCH a b\r\nOK\r\n127.0.0.1:6379> MULTI\r\nOK\r\n127.0.0.1:6379> set a 2\r\nQUEUED\r\n127.0.0.1:6379> set b 2\r\nQUEUED\r\n127.0.0.1:6379> EXEC\r\n1) OK\r\n2) OK\r\n127.0.0.1:6379>\r\n# 简单的解决办法 就是如果事务执行失败 那么我们就释放监视 新获取\r\n127.0.0.1:6379> set b 3\r\nOK\r\n127.0.0.1:6379> get a\r\n\"3\"\r\n127.0.0.1:6379> get b\r\n\"3\"\r\n127.0.0.1:6379> get b\r\n\"2\"\r\n127.0.0.1:6379> get a\r\n\"2\"\r\n127.0.0.1:6379>\r\n\r\n```\r\n### jedis\r\n我们要使用java来操作redis\r\n\r\n```bash\r\n什么是jedis 是redis官方推荐的java连接开发工具！使用java操作redis中间件，\r\n如果你要使用java操作redis，那么一定要对jedis十分熟悉。\r\n```\r\njedis 的包\r\n1. 导入依赖\r\n```xml\r\n<!-- jedis -->\r\n<dependency>\r\n	<groupId>redis.clients</groupId>\r\n	<artifactId>jedis</artifactId>\r\n	<version>3.2.0<version>\r\n</dependency>\r\n<!-- fastjson -->\r\n<dependency>\r\n	<groupId>com.alibaba</groupId>\r\n	<artifactId>fastjson</artifactId>\r\n	<version>1.2.60</version>\r\n</dependency>\r\n</dependency>\r\n```\r\n2. 编码测试\r\n     1.连接数据库\r\n  \r\n\r\n```java\r\n//在本地先打开redis服务\r\npublic class TestPing {\r\n	public static void main(String[] args) {\r\n//		1. new Jedis 对象即可\r\n		Jedis jedis = new Jedis(\"127.0.0.1\",6379);\r\n//		jedis所有的目录就是我们之前学习的所有命令 \r\n		System.out.println(jedis.ping());//PONG \r\n	}\r\n}\r\n\r\n```\r\n   2. 操作命令\r\n\r\n```java\r\npublic class TestPing {\r\n	public static void main(String[] args) {\r\n		\r\n//		1. new Jedis 对象即可\r\n		Jedis jedis = new Jedis(\"127.0.0.1\",6379);\r\n		System.out.println(jedis.ping());\r\n//		jedis所有的目录就是我们之前学习的所有命令 \r\n		System.out.println(\"清空数据:\"+jedis.flushDB());//当前数据库 默认为0\r\n		System.out.println(\"判断某个键是否存在:\"+jedis.exists(\"username\"));\r\n		System.out.println(\"新镇username : xiaobai键值对：\"+jedis.set(\"username\", \"xiaobai\"));\r\n		System.out.println(\"新镇passwrod : 123键值对：\"+jedis.set(\"passwrod\", \"123\"));\r\n		System.out.println(\"系统中所有键如下：\");\r\n		Set<String> keys = jedis.keys(\"*\");\r\n		System.out.println(keys);\r\n		System.out.println(\"删除键passwrod\"+jedis.del(\"passwrod\"));\r\n		System.out.println(\"判断passwrod是否存在\"+jedis.exists(\"passwrod\"));\r\n		System.out.println(\"查看键username所存储的值得类型\"+jedis.exists(\"username\"));\r\n		System.out.println(\"随机返回key空间的一个\"+jedis.randomKey());\r\n		System.out.println(\"重命名key\"+jedis.rename(\"username\", \"name\"));\r\n		System.out.println(\"取出改后的name\"+jedis.get(\"name\"));\r\n		System.out.println(\"按照索引查询\"+jedis.select(0));\r\n		System.out.println(\"删除当前数据库中的所有key\"+jedis.flushDB());\r\n		System.out.println(\"返回当前数据库key的数目\"+jedis.dbSize());\r\n		System.out.println(\"删除所有数据库的所有的key\"+jedis.flushAll());\r\n		PONG\r\n/*\r\n		清空数据:OK\r\n		判断某个键是否存在:false\r\n		新镇username : xiaobai键值对：OK\r\n		新镇passwrod : 123键值对：OK\r\n		系统中所有键如下：\r\n		[passwrod, username]\r\n		删除键passwrod1\r\n		判断passwrod是否存在false\r\n		查看键username所存储的值得类型true\r\n		随机返回key空间的一个username\r\n		重命名keyOK\r\n		取出改后的namexiaobai\r\n		按照索引查询OK\r\n		删除当前数据库中的所有keyOK\r\n		返回当前数据库key的数目0\r\n		删除所有数据库的所有的keyOK\r\n*/\r\n\r\n	}\r\n}\r\n\r\n```\r\n   3. 断开连接\r\n\r\n\r\n**java 操作事务**\r\n\r\n```java\r\npublic class TestPing {\r\n	public static void main(String[] args) {\r\n		\r\n//		1. new Jedis 对象即可\r\n		Jedis jedis = new Jedis(\"127.0.0.1\",6379);\r\n		System.out.println(jedis.ping());\r\n		\r\n		JSONObject jsonObject = new JSONObject();\r\n		jsonObject.put(\"hello\", \"wrold\");\r\n		jsonObject.put(\"name\", \"xiaobai\");\r\n	\r\n		String jsonString = jsonObject.toJSONString();\r\n		\r\n		//开启事务\r\n		Transaction multi = jedis.multi();\r\n		\r\n		try {\r\n			multi.set(\"user1\",jsonString);\r\n			multi.set(\"user2\",jsonString);\r\n			\r\n			multi.exec();//执行事务\r\n		} catch (Exception e) {\r\n			// TODO Auto-generated catch block\r\n			multi.discard();//放弃事务\r\n			e.printStackTrace();\r\n		}finally {\r\n			System.out.println(jedis.get(\"user1\"));\r\n			System.out.println(jedis.get(\"user2\"));\r\n			jedis.close();\r\n		}\r\n	}\r\n}\r\n\r\n```\r\n**springboot整合redis**\r\n\r\n**springboot操作数据：springboot-data jpa jdbcmongodb redis**\r\n\r\n**springboot data  也是springboot齐名的项目！**\r\n\r\n**说明在：springboot2.X之后，原来使用的redsi被替换了lettuce (1.xx之前是jedis)**\r\n\r\n**jedis：采用的直连，多个线程操作的话，是不安全的，如果想要被避免不按照，使用dedis poll连接池！BIO 阻塞的**\r\n\r\n**lettuce：采用netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数据了，更像NIO模式。**\r\n\r\n\r\n```xml\r\n<!--查看jar包-->\r\n<dependency>\r\n   <groupId>org.springframework.boot</groupId>\r\n   <artifactId>spring-boot-starter-data-redis</artifactId>\r\n   <version>2.2.0.RELEASE</version>\r\n </dependency>\r\n\r\n<dependency>\r\n   <groupId>io.lettuce</groupId>\r\n    <artifactId>lettuce-core</artifactId>\r\n    <version>5.2.0.RELEASE</version>\r\n    <scope>compile</scope>\r\n</dependency>\r\n\r\n <dependency>\r\n	<groupId>io.netty</groupId>\r\n    <artifactId>netty-bom</artifactId>\r\n    <version>${netty-version}</version>\r\n    <type>pom</type>\r\n    <scope>import</scope>\r\n</dependency>\r\n\r\n```\r\n**源码**\r\n\r\n```java\r\n@Configuration(proxyBeanMethods = false)\r\n@ConditionalOnClass(RedisOperations.class)\r\n@EnableConfigurationProperties(RedisProperties.class)\r\n@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })\r\npublic class RedisAutoConfiguration {\r\n\r\n	@Bean\r\n	@ConditionalOnMissingBean(name = \"redisTemplate\")\r\n	//如果这个bean 不存在 就使用\r\n	public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\r\n			throws UnknownHostException {\r\n		//默认的 RedisTemplate的没有过多的设置 redis redis对象都是需要序列化的\r\n		//俩个泛型都是object的 我们要转化为 String object\r\n		RedisTemplate<Object, Object> template = new RedisTemplate<>();\r\n		template.setConnectionFactory(redisConnectionFactory);\r\n		return template;\r\n	}\r\n\r\n	@Bean\r\n	@ConditionalOnMissingBean\r\n	//String常用 所有单独抽出\r\n	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)\r\n			throws UnknownHostException {\r\n		StringRedisTemplate template = new StringRedisTemplate();\r\n		template.setConnectionFactory(redisConnectionFactory);\r\n		return template;\r\n	}\r\n\r\n}\r\n```\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602094932373.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n1.导入jar包\r\n\r\n```java\r\n<!-- 操作 redis -->\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n	<artifactId>spring-boot-starter-data-redis</artifactId>\r\n</dependency>\r\n```\r\n2.配置连接\r\n\r\n```properties\r\nspring.redis.host=127.0.0.1\r\nspring.redis.port=6379\r\n```\r\n\r\n3.代码演示\r\n\r\n```java\r\n	@Autowired\r\n	@Qualifier(value = \"redisTemplate\")\r\n	private RedisTemplate<String, Object> redisTemplate;\r\n	\r\n	@Test\r\n	void contextLoads() {\r\n//		redisTemplate 操作不同的数据类型 api和我们的指令是一样的\r\n//		redisTemplate.opsForValue() 操作字符串 类似于 string\r\n//		redisTemplate.opsForList() //操作List 类似于list\r\n//		redisTemplate.opsForSet()\r\n//		redisTemplate.opsForHash()\r\n//		redisTemplate.opsForZSet()\r\n//		redisTemplate.opsForGeo()\r\n//		redisTemplate.opsForHyperLogLog()\r\n//		除了进行的操作，我们常用的方法都是=可以直接通过redisTemplate操作，比如事务 和基本的crud\r\n//		获取redis的连接对象\r\n//		RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();\r\n//		connection.flushDb();\r\n//		connection.flushAll();\r\n//		redisTemplate.opsForValue().set(\"m\", \"123\");\r\n//		\r\n//		System.out.println(redisTemplate.opsForValue().get(\"m\"));\r\n		System.out.println(redisTemplate);\r\n		\r\n	}\r\n\r\n```\r\n**默认序列化方式jdk （源码）**\r\n```java\r\n\r\n	public void afterPropertiesSet() {\r\n\r\n		super.afterPropertiesSet();\r\n\r\n		boolean defaultUsed = false;\r\n\r\n		if (defaultSerializer == null) {\r\n\r\n			defaultSerializer = new JdkSerializationRedisSerializer(\r\n					classLoader != null ? classLoader : this.getClass().getClassLoader());\r\n		}\r\n\r\n		if (enableDefaultSerializer) {\r\n\r\n			if (keySerializer == null) {\r\n				keySerializer = defaultSerializer;\r\n				defaultUsed = true;\r\n			}\r\n			if (valueSerializer == null) {\r\n				valueSerializer = defaultSerializer;\r\n				defaultUsed = true;\r\n			}\r\n			if (hashKeySerializer == null) {\r\n				hashKeySerializer = defaultSerializer;\r\n				defaultUsed = true;\r\n			}\r\n			if (hashValueSerializer == null) {\r\n				hashValueSerializer = defaultSerializer;\r\n				defaultUsed = true;\r\n			}\r\n		}\r\n\r\n		if (enableDefaultSerializer && defaultUsed) {\r\n			Assert.notNull(defaultSerializer, \"default serializer null and not all serializers initialized\");\r\n		}\r\n\r\n		if (scriptExecutor == null) {\r\n			this.scriptExecutor = new DefaultScriptExecutor<>(this);\r\n		}\r\n\r\n		initialized = true;\r\n	}\r\n```\r\n自定义RedisTemplate\r\n\r\n```java\r\n@Configuration //配置类\r\npublic class RedisConfig {\r\n	@Bean\r\n	@SuppressWarnings(\"all\")\r\n	public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\r\n			throws UnknownHostException {\r\n		RedisTemplate<String, Object> template = new RedisTemplate<>();\r\n		template.setConnectionFactory(redisConnectionFactory);\r\n		\r\n		//使用json序列化\r\n		Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class);\r\n		ObjectMapper om=new ObjectMapper();\r\n		om.setVisibility(PropertyAccessor.ALL,JsonAutoDetect.Visibility.ANY);\r\n//		om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\r\n		om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);		\r\n		serializer.setObjectMapper(om);\r\n		StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\r\n		\r\n		//key 采用string的序列化方法\r\n		template.setKeySerializer(stringRedisSerializer);\r\n		//hash的key采用string的序列化方法\r\n		template.setHashKeySerializer(stringRedisSerializer);\r\n		 //value 的序列化使用jackJson的\r\n		template.setValueSerializer(serializer);\r\n		//hash的value采用string的序列化方法\r\n		template.setHashValueSerializer(serializer);\r\n		template.afterPropertiesSet();\r\n\r\n		return template;\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n**所有的对象都需要序列化，不然会报错。**\r\n\r\n```java\r\nUser user = new User(\"a\",23);\r\nredisTemplate.opsForValue().set(\"user\", user);\r\nSystem.out.println(redisTemplate.opsForValue().get(\"user\"));\r\n//User(name=a, age=23)\r\n\r\nUser user = new User(\"a\",23);\r\nObjectMapper objectMapper = new ObjectMapper();\r\nString jsonObject = objectMapper.writeValueAsString(user);\r\nredisTemplate.opsForValue().set(\"user\", jsonObject);\r\nSystem.out.println(jsonObject);//{\"name\":\"a\",\"age\":23}\r\n```\r\n\r\n**仅供参考，方便以后复习！**', '2017-12-01 03:31:38', 'http://img3.a0bi.com/upload/ttq/20160710/1468121126406.jpg', '原创', '', '\0', '', 'redis的事务', '2019-08-24 04:47:28', '109', '4', '1', '10,7', '事务\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n\n\n事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n事务是一个原子操作：事务中的命令要么全部被执');
INSERT INTO `t_blog` VALUES ('1271646522898907136', '\0', '\0', '# redis的基础操作和知识\r\n**Redis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流的地理空间索引。Redis具有内置的复制，Lua脚本，LRU逐出，事务和不同级别的磁盘持久性，并通过Redis Sentinel和Redis Cluster自动分区提供了高可用性。**\r\n### redis的常用配置\r\nredis 的默认数据库有16个，默认使用第一个\r\n在配置文件可以查看\r\n```bash\r\ndatabases 16\r\n```\r\n默认使用第一个数据库\r\n切换数据库\r\n使用select\r\n```bash\r\n127.0.0.1:6379> select 1\r\nOK\r\n127.0.0.1:6379[1]>\r\n```\r\n\r\n查看数据库大小\r\n\r\n```bash\r\n127.0.0.1:6379[1]> set a a\r\nOK\r\n127.0.0.1:6379[1]> dbsize\r\n(integer) 1\r\n127.0.0.1:6379[1]>\r\n# 查看所有的key\r\n127.0.0.1:6379[1]> keys *\r\n1) \"a\"\r\n# 所有的操作值针对于当前数据库  \r\n```\r\n### 基础操作\r\n\r\n==清空数据库==\r\n```bash\r\n# 清空当前数据库\r\n127.0.0.1:6379> flushdb\r\nOK\r\n# 清空所有数据库\r\n127.0.0.1:6379> flushAll\r\nOK\r\n```\r\n> redis为什么是单线程？(6.0已经多线程了)\r\n\r\n**redis是很快的，官方表示，redis是基于内存操作的，cpu表示redis的性能瓶颈，redis的瓶颈是根据机器的内存和网络带宽。既然可以使用单线程实现，就使用单线程！所有就使用单线程了**\r\n\r\n**redis为什么单线程还那么快？**\r\n\r\n 1. 误区：高性能的服务器就一定是多线程的？\r\n 2. 误区：多线程（cpu上下文会切换耗时）一定比单线程效率高！\r\n\r\n**运行速度 cpu>内存>硬盘** \r\n\r\n**核心：redis是将所有的数据全部放在内存中的，所以说使用的单线程是操作效率比较高的，多线程（cpu上下文会切换：耗时的操作！！）对于系统来说，如果没有上下文切换效率就是最高的！多次读写在一个cpu上的，在内存情况下，这个是比较好的方案！**\r\n\r\n**五大数据类型**\r\n\r\n```bash\r\nstring \r\nlist\r\nset\r\nhash\r\nzset\r\n```\r\n**三种特殊类型**\r\n\r\n```bash\r\ngeospatial\r\nhyperloglog\r\nbitmaps\r\n```\r\n判断一个键是否存在\r\n```bash\r\n127.0.0.1:6379> exists a\r\n(integer) 0\r\n127.0.0.1:6379> set a a\r\nOK\r\n127.0.0.1:6379> exists a\r\n(integer) 1\r\n```\r\n移除一个键\r\n\r\n```bash\r\nRedis MOVE 命令用于将当前数据库的 key 移动到给定的数据库 db 当中。\r\n移动成功返回 1 ，失败则返回 0 。\r\n127.0.0.1:6379> get b\r\n\"b\"\r\n\r\n127.0.0.1:6379> move b 1\r\n(integer) 1\r\n127.0.0.1:6379> keys *\r\n(empty list or set)\r\n127.0.0.1:6379>\r\n\r\n```\r\n设置一个键的过期时间\r\n\r\n```bash\r\n127.0.0.1:6379> set a a\r\nOK\r\n127.0.0.1:6379> set b b\r\nOK\r\n127.0.0.1:6379> keys *\r\n1) \"a\"\r\n2) \"b\"\r\n#设置一个键的过期时间\r\n127.0.0.1:6379> expire a 10\r\n(integer) 1\r\n# 查看过期时间\r\n127.0.0.1:6379> ttl a\r\n(integer) 7\r\n```\r\n##### Redis keys 命令\r\n下表给出了与 Redis 键相关的基本命令：\r\n\r\n序号	命令及描述\r\n1	==DEL key==\r\n该命令用于在 key 存在时删除 key。\r\n2	==DUMP key==\r\n序列化给定 key ，并返回被序列化的值。\r\n3	==EXISTS key==\r\n检查给定 key 是否存在。\r\n4	==EXPIRE key seconds==\r\n为给定 key 设置过期时间，以秒计。\r\n5	==EXPIREAT key timestamp==\r\nEXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。\r\n6	==PEXPIRE key milliseconds==\r\n设置 key 的过期时间以毫秒计。\r\n7	==PEXPIREAT key milliseconds-timestamp==\r\n设置 key 过期时间的时间戳(unix timestamp) 以毫秒计\r\n8	==KEYS pattern==\r\n查找所有符合给定模式( pattern)的 key 。\r\n9	==MOVE key db==\r\n将当前数据库的 key 移动到给定的数据库 db 当中。\r\n10	==PERSIST key==\r\n移除 key 的过期时间，key 将持久保持。\r\n11	==PTTL key==\r\n以毫秒为单位返回 key 的剩余的过期时间。\r\n12	==TTL key==\r\n以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。\r\n13	==RANDOMKEY==\r\n从当前数据库中随机返回一个 key 。\r\n14	==RENAME key newkey==\r\n修改 key 的名称\r\n15	==RENAMENX key newkey==\r\n仅当 newkey 不存在时，将 key 改名为 newkey 。\r\n16	==SCAN cursor [MATCH pattern] [COUNT count]==\r\n迭代数据库中的数据库键。\r\n17	==TYPE key==\r\n返回 key 所储存的值的类型。\r\n解释：\r\n [菜鸟链接](https://www.runoob.com/redis/redis-keys.html)\r\n \r\n查看key的类型\r\n\r\n```bash\r\n127.0.0.1:6379> type b\r\nstring\r\n```\r\n#### String类型学习', '2017-03-13 03:32:12', 'http://5b0988e595225.cdn.sohucs.com/images/20190625/06655d3411564ddc9cbe601ea89c9079.jpeg', '原创', '', '', '', 'redis的基础操作', '2018-01-24 04:47:33', '55', '3', '1', '2,7', 'redis的基础操作和知识\n\nRedis是一个开放源代码（BSD许可）的内存中数据结构存储，用作数据库，缓存和消息代理。它支持数据结构，例如字符串，哈希，列表，集合，带范围查询的排序集合，位图，超日志，带有半径查询和流的地理空间索引。Redis');
INSERT INTO `t_blog` VALUES ('1271646782887034880', '\0', '\0', '### redis.conf 详解\r\n启动的时候，就通过配置文件来启动。\r\n\r\n**单位 忽略大小写**\r\n\r\n```java\r\n# Redis configuration file example.\r\n#\r\n# Note that in order to read the configuration file, Redis must be\r\n# started with the file path as first argument:\r\n#\r\n# ./redis-server /path/to/redis.conf\r\n\r\n# Note on units: when memory size is needed, it is possible to specify\r\n# it in the usual form of 1k 5GB 4M and so forth:\r\n#\r\n# 1k => 1000 bytes\r\n# 1kb => 1024 bytes\r\n# 1m => 1000000 bytes\r\n# 1mb => 1024*1024 bytes\r\n# 1g => 1000000000 bytes\r\n# 1gb => 1024*1024*1024 bytes\r\n#\r\n# units are case insensitive so 1GB 1Gb 1gB are all the same.\r\n忽略大小写\r\n```\r\n\r\n**包含**\r\n\r\n**等价与spring中的import include**\r\n\r\n```java\r\n################################## INCLUDES ###################################\r\n\r\n# Include one or more other config files here.  This is useful if you\r\n# have a standard template that goes to all Redis servers but also need\r\n# to customize a few per-server settings.  Include files can include\r\n# other files, so use this wisely.\r\n#\r\n# Notice option \"include\" won\'t be rewritten by command \"CONFIG REWRITE\"\r\n# from admin or Redis Sentinel. Since Redis always uses the last processed\r\n# line as value of a configuration directive, you\'d better put includes\r\n# at the beginning of this file to avoid overwriting config change at runtime.\r\n#\r\n# If instead you are interested in using includes to override configuration\r\n# options, it is better to use include as the last line.\r\n#\r\n# include /path/to/local.conf\r\n# include /path/to/other.conf\r\n```\r\n**网络**\r\n\r\n```java\r\nbind 127.0.0.1 //绑定的ip 可以使用* 表示所有\r\nprotected-mode yes //保护模式\r\nport 6379 //默认端口\r\n```\r\n通用配置\r\n\r\n```java\r\ndaemonize yes \r\n// 以守护进程的方式运行，默认为no 需要自己修改\r\n//守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。\r\n//很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。\r\npidfile /var/run/redis_6379.pid \r\n//如法以后台方式运行，我们就需要制定一个pid文件\r\n/***************************************************/\r\n//日志\r\n# Specify the server verbosity level.\r\n# This can be one of:\r\n# debug (a lot of information, useful for development/testing)\r\n# verbose (many rarely useful info, but not a mess like the debug level)//开发和测试 比较全\r\n# notice (moderately verbose, what you want in production probably) //生产环境\r\n# warning (only very important / critical messages are logged)\r\nloglevel notice\r\n//生成文件名\r\n# Specify the log file name. Also the empty string can be used to force\r\n# Redis to log on the standard output. Note that if you use standard\r\n# output for logging but daemonize, logs will be sent to /dev/null\r\nlogfile \"\" # 日志的文位置名  为空表示标准输出\r\n# 数据库数量\r\ndatabases 16\r\n# 是否显示log\r\nalways-show-logo yes\r\n```\r\n**快照**\r\n持久化 在规定的时间 ，执行了多少次操作，则会持久化到文件 .rdb .aof\r\n内存数据库 ，不持久化就可能丢失 ，断电即使\r\n\r\n```bash\r\n# 如果900秒内，如果至少有一个key进行了修改，我们就进行持久化操作\r\nsave 900 1\r\n# 如果300秒内，如果至少有10 个key进行了修改，我们就进行持久化操作\r\nsave 300 10\r\n# 如果60秒内，如果至少有10000 个key进行了修改，我们就进行持久化操作 高并发\r\nsave 60 10000\r\n# 可以定义测试数据 方便学习\r\n/******************************/\r\n# 如果出现错误 是否继续工作\r\nstop-writes-on-bgsave-error yes\r\n# 是否rdb文件 需要消耗cpu资源\r\nrdbcompression yes\r\n# 报错red文件 的时候 进行错误的检查校验\r\nrdbchecksum yes\r\n# rdb文件保存目录 \r\ndir ./\r\n```\r\n\r\n**复制 REPLICATION**\r\n\r\n**安全 SECURITY**\r\n\r\n```java\r\n默认没有密码 为空 可以自己设置\r\n# 拿到密码为空\r\n127.0.0.1:6379>  CONFIG GET requirepass\r\n1) \"requirepass\"\r\n2) \"\"\r\n# 设置密码 \r\n127.0.0.1:6379> CONFIG SET requirepass \"XXXX\"\r\nOK\r\n127.0.0.1:6379> CONFIG GET requirepass # 获取redis密码\r\n1) \"requirepass\"\r\n2) \"XXXX\"\r\n# 没有权限\r\n[root@VM_0_11_centos bin]# redis-cli -p 6379\r\n127.0.0.1:6379> ping\r\n(error) NOAUTH Authentication required.\r\n# 输入密码\r\n127.0.0.1:6379> AUTH XXXX # 登录输入密码\r\nOK\r\n# 以后连接需要输入密码\r\n127.0.0.1:6379> CONFIG GET requirepass\r\n1) \"requirep\r\n2) \"XXXX\"\r\n\r\n```\r\n\r\n**CLIENTS限制**\r\n\r\n```java\r\n客户端的限制\r\n# 最大能连接redis客户端数量\r\nmaxclients 10000\r\n# redis配置的最大内存\r\nmaxmemory <bytes>\r\n# 内存到达上限之后的处理策略\r\nmaxmemory-policy noeviction\r\n	解决办法：报错\r\n	# maxmemory-policy 六种方式\r\n	1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） \r\n	2、allkeys-lru ： 删除lru算法的key   \r\n	3、volatile-random：随机删除即将过期key   \r\n	4、allkeys-random：随机删除   \r\n	5、volatile-ttl ： 删除即将过期的   \r\n	6、noeviction ： 永不过期，返回错误\r\n```\r\n**APPEND ONLY MODE 模式 aof的配置** \r\n\r\n```bash\r\n# 默认不开启aof模式 默认使用rdb方式持久化 大部分情况够用\r\nappendonly no \r\n# 持久化文件的名字\r\nappendfilename \"appendonly.aof\" # .rdb\r\n\r\n# appendfsync always # 每次修改都会sync。消耗性能（同步）\r\nappendfsync everysec # 美妙执行一次sync。可能会丢失这1s的数据\r\n# appendfsync no     #不执行同步这个时候操作系统自己同步数据，数据最快！\r\n```\r\n\r\n#### Redis持久化（RDB）\r\n在主从复制中，rdb就是备用的！主机上面。\r\nredis是内存数据库，如果不降内存中的数据状态报存到磁盘，那么一旦服务器进程退出，服务器中的数据状态也会消息，所有redis提供了持计划功能。\r\n\r\n```bash\r\n1.save 的规则满足的情况下，会自动触发rdb规则\r\n2.执行flushAll命令，也会触发我们的rdb规则！\r\n3.退出redis，也会产生rdb文件\r\n\r\n备份会自动生成dump.rdb  文件\r\n# 恢复rdb文件\r\n1.只需要将rdb文件放在我们redis启动目录就可以了，redis启动的时候自动检测dump.rdb文件 自动恢复文件内容\r\n2.查看需要存在位置\r\n\r\n127.0.0.1:6379> CONFIG GET dir\r\n1) \"dir\"\r\n2) \"/usr/local/bin\" # 如果这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据\r\n几户就他默认的配置就够用了，但是我们还是需要去学习！\r\n\r\n优点：\r\n	1.适合大规模的数据恢复！\r\n	2.对数据的完整性要不高\r\n缺点：\r\n	1.需要一定的时间间隔！如果redis意外宕机了，这个最后一次修改的数据就没了\r\n	2.fork进程的时候，会占用一定的内存空间！\r\n```\r\n#### Redis持久化（AOF）\r\n**将我们的所有的命令都记录下来，history，恢复的时候把这个文件全部指向一遍。**\r\n\r\n以日志的形式记录每个写操作，将redis执行过程过得所有指令记录下来（读操作不记录），只许追加文件，但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis启动的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。\r\n\r\n==aof保存的是appendonly。aof文件==\r\naof模式就是默认的文件无限追加，文件越来越大！\r\n```bash\r\n# 默认不开启\r\nappendonly no\r\n# 文件名字\r\nappendfilename \"appendonly.aof\"\r\n# 如果这个aof文件有错误。这个时候redis是启动不起来的，我们需要修复这个aof文件redis给我提供了一个工具，redis-check-aof  --fix 文件名\r\nredis-check-aof  --fix appendonly.aof\r\n# rewrite 重写 \r\n# 根据文件的大小判断是否是当前文件，如果aof太大64m，fork一个新的进程来讲我们的文件进行重写\r\n\r\n优点：\r\n	1.每一次修改会同步，文件的完整会更好\r\n	2.每秒同步一次，可能会丢失一秒的数据\r\n	3.从不同步，效率高\r\n缺点：\r\n	1.相当于数据文件来说，aof远远大于rdb，修复的数据也比aof快\r\n```\r\n\r\n\r\n**最近在项目中使用到Redis做缓存，方便多个业务进程之间共享数据。由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化），另外一种是AOF持久化（原理是将Reids的操作日志以追加的方式写入文件）。那么这两种持久化方式有什么区别呢，改如何选择呢？网上看了大多数都是介绍这两种方式怎么配置，怎么使用，就是没有介绍二者的区别，在什么应用场景下使用。**\r\n\r\n \r\n\r\n**2、二者的区别**\r\n\r\nRDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602174545860.png)\r\n\r\n\r\n \r\n\r\nAOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602174554195.png)\r\n\r\n \r\n\r\n3、二者优缺点\r\n\r\n**RDB存在哪些优势呢？**\r\n\r\n1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。\r\n\r\n2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。\r\n\r\n3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。\r\n\r\n4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。\r\n\r\n**RDB又存在哪些劣势呢？**\r\n\r\n1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。\r\n\r\n2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。\r\n\r\n**AOF的优势有哪些呢？**\r\n\r\n1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。\r\n\r\n2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。\r\n\r\n3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。\r\n\r\n4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。\r\n\r\n**AOF的劣势有哪些呢？**\r\n\r\n1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。\r\n\r\n2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。\r\n\r\n二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。不过生产环境其实更多都是二者结合使用的。\r\n\r\n \r\n\r\n**4、常用配置**\r\n\r\n**RDB持久化配置**\r\n\r\nRedis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：\r\n\r\nsave 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。\r\n\r\nsave 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。\r\n\r\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。\r\n\r\n**AOF持久化配置**\r\n\r\n在Redis的配置文件中存在三种同步方式，它们分别是：\r\n\r\nappendfsync always     #每次有数据修改发生时都会写入AOF文件。\r\n\r\nappendfsync everysec  #每秒钟同步一次，该策略为AOF的缺省策略。\r\n\r\nappendfsync no          #从不同步。高效但是数据不会被持久化。\r\n\r\n \r\n\r\n5.redis启用持久化 aof 之后 报错\r\n\r\nCan\'t open the append-only file: Input/output error \r\n\r\n是因为 在win下 没用管理员权限 （一个坑）\r\n\r\n### redis 发布订阅\r\n**redis发布订阅(pub/sub)是一种消息通信模式：发送者pub发送消息，订阅者sub接受消息。**\r\n\r\n**redis客户端就可以订阅容易数量的频道。**\r\n\r\n**订阅/发布消息图：**\r\n\r\n第一个：消息发送者\r\n第二个：频道\r\n第三个：消息订阅者\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602175033517.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200602175227919.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n### redis主从复制\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605104617197.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n一般来说，要讲redis运用于项目工程中，只使用一台redis是万万不能得。原因如下：\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060510491662.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n主从复制，读写分离，80%的情况下都是在进行读操作，减缓服务器的压力，架构中经常使用，一主二从！只要在公司中，主从复制就必须要使用的人，在真实项目中，不会使用单机，性能问题。\r\n### 环境配置\r\n只配置从库，不用配置主库！\r\n\r\n```bash\r\n127.0.0.1:6379> info replication # 查看当前库的信息\r\n# Replication\r\nrole:master #角色 master\r\nconnected_slaves:0 # 没有从级\r\nmaster_replid:18148e3ceb5e80c5be812f493b99e1bf28c3d785\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:0\r\nmaster_repl_meaningful_offset:0\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:0\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:0\r\nrepl_backlog_histlen:0\r\n127.0.0.1:6379>\r\n\r\n```\r\n**搭建集群注意点**\r\n\r\n复制三个文件  修改信息 修改信息注意点：\r\n1. port 端口应该不愿意   **port 6381**\r\n2. 进程pid应该不一样  **pidfile /var/run/redis_6381.pid**\r\n3. 日志文件不一样    **logfile  6381.log**\r\n4. rdb文件不一样      **dbfilename dump6381.rdb**\r\n5. 都需要后台启动  **daemonize yes** \r\n  \r\n  启动三个服务\r\n  \r\n\r\n```bash\r\n[root@VM_0_11_centos bin]# ps -ef |grep redis\r\nroot     11350     1  0 11:13 ?        00:00:00 redis-server 127.0.0.1:6379\r\nroot     11362     1  0 11:13 ?        00:00:00 redis-server 127.0.0.1:6380\r\nroot     12286     1  0 11:19 ?        00:00:00 redis-server 127.0.0.1:6381\r\nroot     12317  9108  0 11:19 pts/1    00:00:00 grep --color=auto redis\r\n```\r\n### 主从复制原理\r\n一主二从\r\n默认情况下，每一台redis服务器都是主节点，我们一般情况下只配置从机就好了。\r\n认老大！一主（79） 二从（80,81）\r\n\r\n**从机认主**\r\n\r\n```bash\r\n127.0.0.1:6380> SLAVEOF 127.0.0.1 6379  # 主机ip 主机 端口\r\nOK\r\n127.0.0.1:6380> info replication\r\n# Replication\r\nrole:slave\r\nmaster_host:127.0.0.1\r\nmaster_port:6379\r\nmaster_link_status:up\r\nmaster_last_io_seconds_ago:3\r\nmaster_sync_in_progress:0\r\nslave_repl_offset:0\r\nslave_priority:100\r\nslave_read_only:1\r\nconnected_slaves:0\r\nmaster_replid:053b1c11c348a37e2f38b42033cad27c2af1e017\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:0\r\nmaster_repl_meaningful_offset:0\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:0\r\n127.0.0.1:6380>\r\n\r\n```\r\n**主机现在的配置**\r\n\r\n```bash\r\n127.0.0.1:6379> info replication\r\n# Replication\r\nrole:master\r\nconnected_slaves:1\r\nslave0:ip=127.0.0.1,port=6380,state=online,offset=154,lag=1\r\nmaster_replid:053b1c11c348a37e2f38b42033cad27c2af1e017\r\nmaster_replid2:0000000000000000000000000000000000000000\r\nmaster_repl_offset:154\r\nmaster_repl_meaningful_offset:0\r\nsecond_repl_offset:-1\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:1\r\nrepl_backlog_histlen:154\r\n127.0.0.1:6379>\r\n\r\n```\r\n**真实主从配置 应该配置文件中配置，这样的话就永久的，我们这里使用的是命令，暂时的！**\r\n\r\n**配置文件地方：**\r\n\r\n```bash\r\n# 配置主机信息\r\n# replicaof <masterip> <masterport>\r\n# 配置主机密码 有的话\r\n# masterauth <master-password>\r\n\r\n```\r\n从机只能读，不能写\r\n\r\n```bash \r\n# 从机\r\n127.0.0.1:6380> keys *\r\n1) \"k1\"\r\n127.0.0.1:6380> set k2 v2\r\n(error) READONLY You can\'t write against a read only replica.\r\n127.0.0.1:6380>\r\n```\r\n**测试：主机断开连接，从机依旧连接到主机，但是没有写的操作，这个时候如果主机回来了的，从机依旧可以直接获取主机信息！**\r\n\r\n**如果是使用命令行，来配置的主从，这个时候从机如果重启了，那么就会变回主机。但是只要再次配置为从机，那么从机机会里面获取主机中的值。**\r\nsync=同步\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605114932996.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**现在的模式是一个主机俩个从机**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605115349151.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**现在测试下一个**\r\n\r\n79->80->81\r\nm   s m     s\r\n次数80应该是从节点不能写入。\r\n\r\n**层层链路**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200605115828620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**在79设置的值，80和81都能拿到**\r\n\r\n这时候也可以完成我们的主从复制！\r\n\r\n**如果没有老大了，这个时候能不能选择一个老大？**\r\n\r\n如果主机断开连接了，我们可以使用==slaveof no one==使自己变为主节点（手动）！如果这个时候老大回来了，那就只能重新配置了。（哨兵模式可以解决）\r\n\r\n### 哨兵模式\r\n（自动选举老大的模式\r\n\r\n**主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就是需要人工干预，费时费力，还会造成一段时间内服务器不可用，这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。redis从2.8开始提供了sentinel（哨兵模式）结构来解决这问题。**\r\n\r\n**谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了要根据投票**==自动将从库转化为主库。==\r\n\r\n**哨兵模式是一种特殊的模式，首先redis提供了哨兵模式的命令，哨兵是一个独立的进程，作为进程，他会独立运行，器原理是哨兵通过发送命令，等待redis服务器响应，从而监控运行的多个redis实例。**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606095222790.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n\r\n\r\n\r\n这里的哨兵有俩个作用：\r\n \r\n 1. 通过发送命令，让redis服务器返回监控其运行状态，包括主服务器和从服务器。\r\n 2. 当哨兵检测到master宕机后，会自动将slave切换成master，然后通过发布订阅通知其他的从服务器，修改配置文件，让他们切换主机\r\n\r\n然而一个哨兵进程对redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控，这样流行成了多哨兵模式。\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606095716836.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606095745582.jpg)\r\n\r\n我们的目前的状态是一主二从！\r\n1. 配置哨兵配置文件 sentinel.conf\r\n\r\n```bash\r\n# sentinel monitor 监控的名称 host  port 1\r\nsentinel monitor myredis 127.0.0.1 6379 1\r\n```\r\n后面的数字1，代表主机挂了，slave投票看谁替成为主机。票数最多，就会成为主机！\r\n\r\n2. 启动哨兵\r\n\r\n```bash\r\n# 启动 主机下面还有俩个从机  监控的是6379\r\n[root@VM_0_11_centos bin]# redis-sentinel myconfig/sentinel.conf\r\n10534:X 06 Jun 2020 10:18:19.662 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n10534:X 06 Jun 2020 10:18:19.662 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=10534, just started\r\n10534:X 06 Jun 2020 10:18:19.662 # Configuration loaded\r\n                _._\r\n           _.-``__ \'\'-._\r\n      _.-``    `.  `_.  \'\'-._           Redis 6.0.3 (00000000/0) 64 bit\r\n  .-`` .-```.  ```\\/    _.,_ \'\'-._\r\n (    \'      ,       .-`  | `,    )     Running in sentinel mode\r\n |`-._`-...-` __...-.``-._|\'` _.-\'|     Port: 26379\r\n |    `-._   `._    /     _.-\'    |     PID: 10534\r\n  `-._    `-._  `-./  _.-\'    _.-\'\r\n |`-._`-._    `-.__.-\'    _.-\'_.-\'|\r\n |    `-._`-._        _.-\'_.-\'    |           http://redis.io\r\n  `-._    `-._`-.__.-\'_.-\'    _.-\'\r\n |`-._`-._    `-.__.-\'    _.-\'_.-\'|\r\n |    `-._`-._        _.-\'_.-\'    |\r\n  `-._    `-._`-.__.-\'_.-\'    _.-\'\r\n      `-._    `-.__.-\'    _.-\'\r\n          `-._        _.-\'\r\n              `-.__.-\'\r\n\r\n10534:X 06 Jun 2020 10:18:19.664 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\r\n10534:X 06 Jun 2020 10:18:19.676 # Sentinel ID is 0c9a63f1e561cbd8e75cc5a99587c5b283acc1f9\r\n10534:X 06 Jun 2020 10:18:19.676 # +monitor master myredis 127.0.0.1 6379 quorum 1\r\n10534:X 06 Jun 2020 10:18:19.677 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:18:19.681 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n\r\n```\r\n**此时故意将6379的服务关掉**\r\n\r\n```bash\r\n127.0.0.1:6379> SHUTDOWN\r\nnot connected> exit\r\n```\r\n**此时哨兵监控输出**\r\n\r\n```bash\r\n[root@VM_0_11_centos bin]# redis-sentinel myconfig/sentinel.conf\r\n10534:X 06 Jun 2020 10:18:19.662 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n10534:X 06 Jun 2020 10:18:19.662 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=10534, just started\r\n10534:X 06 Jun 2020 10:18:19.662 # Configuration loaded\r\n                _._\r\n           _.-``__ \'\'-._\r\n      _.-``    `.  `_.  \'\'-._           Redis 6.0.3 (00000000/0) 64 bit\r\n  .-`` .-```.  ```\\/    _.,_ \'\'-._\r\n (    \'      ,       .-`  | `,    )     Running in sentinel mode\r\n |`-._`-...-` __...-.``-._|\'` _.-\'|     Port: 26379\r\n |    `-._   `._    /     _.-\'    |     PID: 10534\r\n  `-._    `-._  `-./  _.-\'    _.-\'\r\n |`-._`-._    `-.__.-\'    _.-\'_.-\'|\r\n |    `-._`-._        _.-\'_.-\'    |           http://redis.io\r\n  `-._    `-._`-.__.-\'_.-\'    _.-\'\r\n |`-._`-._    `-.__.-\'    _.-\'_.-\'|\r\n |    `-._`-._        _.-\'_.-\'    |\r\n  `-._    `-._`-.__.-\'_.-\'    _.-\'\r\n      `-._    `-.__.-\'    _.-\'\r\n          `-._        _.-\'\r\n              `-.__.-\'\r\n\r\n10534:X 06 Jun 2020 10:18:19.664 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.\r\n10534:X 06 Jun 2020 10:18:19.676 # Sentinel ID is 0c9a63f1e561cbd8e75cc5a99587c5b283acc1f9\r\n10534:X 06 Jun 2020 10:18:19.676 # +monitor master myredis 127.0.0.1 6379 quorum 1\r\n10534:X 06 Jun 2020 10:18:19.677 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:18:19.681 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.571 # +sdown master myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.571 # +odown master myredis 127.0.0.1 6379 #quorum 1/1\r\n10534:X 06 Jun 2020 10:20:51.571 # +new-epoch 1\r\n10534:X 06 Jun 2020 10:20:51.571 # +try-failover master myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.577 # +vote-for-leader 0c9a63f1e561cbd8e75cc5a99587c5b283acc1f9 1\r\n10534:X 06 Jun 2020 10:20:51.577 # +elected-leader master myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.577 # +failover-state-select-slave master myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.632 # +selected-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.632 * +failover-state-send-slaveof-noone slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.722 * +failover-state-wait-promotion slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.878 # +promoted-slave slave 127.0.0.1:6381 127.0.0.1 6381 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.878 # +failover-state-reconf-slaves master myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:51.948 * +slave-reconf-sent slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:52.968 * +slave-reconf-inprog slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:52.968 * +slave-reconf-done slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:53.052 # +failover-end master myredis 127.0.0.1 6379\r\n10534:X 06 Jun 2020 10:20:53.052 # +switch-master myredis 127.0.0.1 6379 127.0.0.1 6381\r\n10534:X 06 Jun 2020 10:20:53.052 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ myredis 127.0.0.1 6381\r\n10534:X 06 Jun 2020 10:20:53.052 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\r\n10534:X 06 Jun 2020 10:21:23.099 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\r\n\r\n```\r\n**根据上面提示信息，此时6381位从机**\r\n\r\n```bash\r\n# 里面有一个选举算法 \r\n127.0.0.1:6381> info replication\r\n# Replication\r\nrole:master\r\nconnected_slaves:1\r\nslave0:ip=127.0.0.1,port=6380,state=online,offset=34999,lag=0\r\nmaster_replid:8222f363eb77f8b7641febc5c2df29aaf928b4be\r\nmaster_replid2:43d9c4b44b3dc19c2cb927b33dc010663e2ee4b6\r\nmaster_repl_offset:34999\r\nmaster_repl_meaningful_offset:34999\r\nsecond_repl_offset:19211\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:5619\r\nrepl_backlog_histlen:29381\r\n127.0.0.1:6381>\r\n\r\n```\r\n**如果master节点断开了，这个时候就会从从机中随机一个服务器！随机的，有一个投票算法。**\r\n\r\n如果此时6379会来了，也只能变为从机了，变为6381的从机\r\n\r\n```bash\r\n127.0.0.1:6381> info replication\r\n# Replication\r\nrole:master\r\nconnected_slaves:2\r\nslave0:ip=127.0.0.1,port=6380,state=online,offset=62670,lag=1\r\nslave1:ip=127.0.0.1,port=6379,state=online,offset=62538,lag=1\r\nmaster_replid:8222f363eb77f8b7641febc5c2df29aaf928b4be\r\nmaster_replid2:43d9c4b44b3dc19c2cb927b33dc010663e2ee4b6\r\nmaster_repl_offset:62670\r\nmaster_repl_meaningful_offset:62670\r\nsecond_repl_offset:19211\r\nrepl_backlog_active:1\r\nrepl_backlog_size:1048576\r\nrepl_backlog_first_byte_offset:5619\r\nrepl_backlog_histlen:57052\r\n127.0.0.1:6381>\r\n```\r\n```bash\r\n127.0.0.1:6379> info replication\r\n# Replication\r\nrole:slave\r\nmaster_host:127.0.0.1\r\nmaster_port:6381\r\n```\r\n\r\n哨兵日志：\r\n\r\n```bash\r\n10534:X 06 Jun 2020 10:30:24.773 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ myredis 127.0.0.1 6381\r\n```\r\n**数据依然存在！**\r\n\r\n**过程描述：**\r\n\r\n**首先6379作为主机，有俩个从机分别为6380和6381，使用哨兵监控127.0.0.1 6379的服务，此时6379主机断掉，哨兵就从俩个从机中选择一个作为主机，此时主机为6381，这个时候我们的6379回来了，也只能作为6381的从机，不能再做主机了，也就是6379变为从机了。**\r\n\r\n优点：\r\n  1. 哨兵集群，基于主从复制模式，所有的主从配置优点，它都有。\r\n  2. 主从可以切换，故障可以转移，系统的可用性就会更好\r\n  3. 哨兵模式就是主从模式的升级，手动到自动，更加健壮!\r\n  \r\n 缺点：\r\n 1.  redis不好在线扩容，集群容量一旦到达上限，在线扩容就十分麻烦！\r\n 2. 实现哨兵模式的配置其实是很麻烦的，里面有很多选择！\r\n\r\n**哨兵模式的全部配置！**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020060610471475.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606104915403.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/202006061050199.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n### redis缓存穿透和雪崩\r\n', '2018-07-01 03:33:14', 'http://5b0988e595225.cdn.sohucs.com/images/20190416/5863c1c0e3c644c6ba368138376db8f5.jpeg', '原创', '', '', '', 'redis的配置文件', '2017-06-24 04:47:23', '4', '3', '1', '7,10,6', 'redis.conf 详解\n\n启动的时候，就通过配置文件来启动。\n\n\n单位 忽略大小写\n\n# Redis configuration file e');
INSERT INTO `t_blog` VALUES ('1271647463249281024', '', '', '### 微信小程序(订阅消息)\r\n	订阅消息的基本操作\r\n	\r\n**最近在学习小程序，老师要求看官方文档操作订阅消息，搞了半天，遇到各种坑，终于完成了，记录下步骤**\r\n\r\n**安装官方文档来**\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527201314198.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**第一步 ：解决模板问题。**\r\n\r\n**登录小程序，获取模板，添加模板**\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527201521743.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**页面代码 一个按钮即可**\r\n\r\n```html\r\n  <button class=\"submit-btn\" bindtap=\"btnClick\">发送模板消息</button>\r\n ```\r\n\r\n\r\n**第二步：获取下发权限**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527201949278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527202056384.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n```javascript\r\nPage({\r\n	access_token: null,\r\n	touser: null,\r\n	template_id: \"模板id\"\r\n	btnClick: function (e) {\r\n		var that=this;\r\n		//获取access_token\r\n		this.getAccess_token();\r\n		//接收者（用户）的 openid\r\n		this.getOpenid();\r\n		//获取下发权限\r\n		wx.requestSubscribeMessage({\r\n			tmplIds: [\"模板id\"],\r\n			success: function (res) {\r\n				console.log(res);\r\n				if (res[\"模板id\"] == \'accept\') {\r\n					//发送消息\r\n					that.sendMsg();\r\n				} else {\r\n					console.log(\"未授权\");\r\n				}\r\n			}\r\n		});\r\n	}\r\n)}\r\n```\r\n\r\n**如果点击按钮 显示 授权成功  代表即可发送消息**\r\n\r\n**步骤三：调用接口下发订阅消息\r\n详见服务端消息发送接口 subscribeMessage.send**\r\n\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020052720265277.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**我们这个三个属性 我们一个一个获取**\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527202800158.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527202807953.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**调用接口 获取 access_token**\r\n\r\n```javascript\r\ngetAccess_token: function () {\r\n	wx.request({\r\n		url: \"https://api.weixin.qq.com/cgi-bin/token\",\r\n		data: {\r\n			grant_type: \'client_credential\', //默认的\r\n			appid: \'wx11111111111111111\', //appId(填写自己的)\r\n			secret: \'aaaaaaaaaa\' //小程序密钥,在小程序后台获取的，登录程序后台->点开发->点开发设置->获取密钥\r\n		},\r\n		success: (req) => {\r\n			console.log(\"获取access_token成功\");\r\n			console.log(req.data.access_token);\r\n			this.access_token = req.data.access_token;\r\n		},\r\n		fail: function () {\r\n			console.log(\"获取access_token失败\");\r\n		},\r\n	})\r\n},\r\n```\r\n**获取接收者（用户）的 openid**\r\n\r\n```javascript\r\ngetOpenid: function () {\r\n	var that = this;\r\n	wx.login({\r\n		success: function (res) {\r\n			console.log(\"code\" + res.code);\r\n			if (res.code) {\r\n				wx.request({\r\n					url: \'https://api.weixin.qq.com/sns/jscode2session\',\r\n					data: {\r\n						appid: \'wx11111111111111111\',\r\n						secret: \'aaaaaaaaaa\',\r\n						js_code: res.code, //登录时获取的code\r\n						grant_type: \"authorization_code\", //授权类型，默认的\r\n					},\r\n					success: (res) => {\r\n						//获取openid\r\n						console.log(\'获取openid成功\', res.data.openid);\r\n						that.touser = res.data.openid;\r\n					},\r\n					fail: function () {\r\n						console.log(\"获取openid成功失败\");\r\n					}\r\n				})\r\n			}\r\n		}\r\n	});\r\n},\r\n```\r\n**发送消息**\r\n\r\n```javascript\r\n	//发送消息\r\nsendMsg: function () {\r\n	var that=this;\r\n	//发送接口\r\n	wx.request({\r\n		url: \"https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=\" +that.access_token,\r\n		method: \"POST\",\r\n		data: {\r\n			touser: that.touser,\r\n			template_id: that.template_id,\r\n			data: {\r\n				thing4: {\r\n					value: \"啊啊啊啊啊\"\r\n				},\r\n				thing3: {\r\n					value: \"啊啊啊啊啊1\"\r\n				},\r\n				time2: {\r\n					value: \"2019年10月1日 15:01\"\r\n				},\r\n				thing1: {\r\n					value: \"啊啊啊啊啊\"\r\n				}\r\n			}\r\n\r\n		},\r\n		success: function (res) {\r\n			console.log(res);\r\n			console.log(\"ok\");\r\n		}\r\n	});\r\n}\r\n```\r\n\r\n\r\n**学习过程遇坑**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527210826701.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527210851673.jpg)\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527210918870.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**data里面的数据一定要符合模板要求，同时数据一定要根据订阅消息内容来，这里看错之后卡了好久，真蠢啊。**\r\n\r\n**完整代码**\r\n\r\n```javascript\r\n// pages/guest/guest.js\r\nPage({\r\n	access_token: null,\r\n	touser: null,\r\n	template_id: \"模板id\",\r\n	btnClick: function (e) {\r\n		var that=this;\r\n		//获取access_token\r\n		this.getAccess_token();\r\n		//接收者（用户）的 openid\r\n		this.getOpenid();\r\n		//获取下发权限\r\n		wx.requestSubscribeMessage({\r\n			tmplIds: [\"模板id\"],\r\n			success: function (res) {\r\n				console.log(res);\r\n				if (res[\"z模板id\"] == \'accept\') {\r\n					that.sendMsg();\r\n				} else {\r\n					console.log(\"未授权\");\r\n				}\r\n			}\r\n		});\r\n	},\r\n	getAccess_token: function () {\r\n		wx.request({\r\n			url: \"https://api.weixin.qq.com/cgi-bin/token\",\r\n			data: {\r\n				//默认的\r\n				grant_type: \'client_credential\', \r\n				//小程序的appId(填写自己的)\r\n				appid: \'appid\', \r\n				//小程序密钥,在小程序后台获取的，登录小程序后台->点开发->点开发设置->获取密钥就可\r\n				secret: \'secret\' \r\n			},\r\n			success: (req) => {\r\n				console.log(\"获取access_token成功\");\r\n				console.log(req.data.access_token);\r\n				this.access_token = req.data.access_token;\r\n			},\r\n			fail: function () {\r\n				console.log(\"获取access_token失败\");\r\n			},\r\n		})\r\n	},\r\n	getOpenid: function () {\r\n		var that = this;\r\n		wx.login({\r\n			success: function (res) {\r\n				console.log(\"code\" + res.code);\r\n				if (res.code) {\r\n					wx.request({\r\n						url: \'https://api.weixin.qq.com/sns/jscode2session\',\r\n						data: {\r\n							appid: \'appid\',\r\n							secret: \'secret\',\r\n							js_code: res.code, //登录时获取的code\r\n							grant_type: \"authorization_code\", //授权类型，写死的\r\n						},\r\n						success: (res) => {\r\n							//获取openid\r\n							console.log(\'获取openid成功\', res.data.openid);\r\n							that.touser = res.data.openid;\r\n						},\r\n						fail: function () {\r\n							console.log(\"获取openid成功失败\");\r\n						}\r\n					})\r\n				}\r\n			}\r\n		});\r\n	},\r\n	//发送消息\r\n	sendMsg: function () {\r\n		var that=this;\r\n		//发送接口\r\n		wx.request({\r\n			url: \"https://api.weixin.qq.com/cgi-bin/message/subscribe/send?access_token=\" +that.access_token,\r\n			method: \"POST\",\r\n			data: {\r\n				touser: that.touser,\r\n				template_id: that.template_id,\r\n				data: {\r\n					thing4: {\r\n						value: \"啊啊啊啊啊\"\r\n					},\r\n					thing3: {\r\n						value: \"啊啊啊啊啊1\"\r\n					},\r\n					time2: {\r\n						value: \"2019年10月1日 15:01\"\r\n					},\r\n					thing1: {\r\n						value: \"啊啊啊啊啊\"\r\n					}\r\n				}\r\n\r\n			},\r\n			success: function (res) {\r\n				console.log(res);\r\n				console.log(\"ok\");\r\n			}\r\n		});\r\n	}\r\n})\r\n\r\n\r\n\r\n```\r\n\r\n**参考即可，如有错误，请勿见怪**\r\n', '2018-05-01 03:35:56', '/images/3.jpg', '原创', '', '', '', '微信小程序', '2020-06-05 05:50:47', '81', '3', '1', '4,5,10', '微信小程序(订阅消息)\n订阅消息的基本操作\n\n\n最近在学习小程序，老师要求看官方文档操作订阅消息，搞了半天，遇到各种坑，终于完成了，记录下步骤\n\n\n安装官方文档');
INSERT INTO `t_blog` VALUES ('1271647674415710208', '', '', '# 搭建简单ssm\r\n\r\n> 最近看完了spring和springmvc以及mybatis，对着视频敲完了所有代码，这次试试对着视频回顾一下ssm的搭建\r\n\r\n```cpp\r\n环境要求:1.jdk1.8\r\n		2.Mysql 8.0\r\n		3.Maven 3.6.3\r\n		4.tomcat 8.5 \r\n		5.eclipse\r\n```\r\n### mysql的搭建\r\n\r\n```sql\r\n/*\r\nNavicat MySQL Data Transfer\r\n\r\nSource Server         : xiaobai\r\nSource Server Version : 80016\r\nSource Host           : localhost:3306\r\nSource Database       : ssmbuild\r\n\r\nTarget Server Type    : MYSQL\r\nTarget Server Version : 80016\r\nFile Encoding         : 65001\r\n\r\nDate: 2020-03-10 16:22:39\r\n*/\r\n\r\nSET FOREIGN_KEY_CHECKS=0;\r\n\r\n-- ----------------------------\r\n-- Table structure for books\r\n-- ----------------------------\r\nDROP TABLE IF EXISTS `books`;\r\nCREATE TABLE `books` (\r\n  `bookID` int(10) NOT NULL AUTO_INCREMENT COMMENT \'书id\',\r\n  `bookName` varchar(100) NOT NULL COMMENT \'书名\',\r\n  `bookCounts` int(11) NOT NULL COMMENT \'数量\',\r\n  `detail` varchar(200) NOT NULL COMMENT \'描述\',\r\n  KEY `bookID` (`bookID`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;\r\n\r\n-- ----------------------------\r\n-- Records of books\r\n-- ----------------------------\r\nINSERT INTO `books` VALUES (\'1\', \'Java\', \'1\', \'从入门到放弃\');\r\nINSERT INTO `books` VALUES (\'2\', \'MySQL\', \'10\', \'从删库到跑路\');\r\nINSERT INTO `books` VALUES (\'3\', \'Linux\', \'5\', \'从进门到进牢\');\r\n\r\n```\r\n### 使用maven创建基础环境（可以跳过）\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310162804615.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310162840161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310162854109.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)==目录结构==\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310163004359.jpg)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031016313493.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n==此时目录结构==\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310163403749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n### maven环境设置\r\n\r\n - 新建一Maven项目！ ssmbuild ， 添加web的支持（已建）\r\n - 导入相关的pom依赖！\r\n - ==pom.xml==\r\n```xml\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n  <groupId>com.myh</groupId>\r\n  <artifactId>ssmTest</artifactId>\r\n  <packaging>war</packaging>\r\n  <version>0.0.1-SNAPSHOT</version>\r\n  <name>ssmTest Maven Webapp</name>\r\n  <url>http://maven.apache.org</url>\r\n\r\n	<!-- juint 数据库驱动 连接池 servlet jsp mybatis mybatis-spring ,spring -->\r\n	<dependencies>\r\n		<!--Junit -->\r\n		<dependency>\r\n			<groupId>junit</groupId>\r\n			<artifactId>junit</artifactId>\r\n			<version>4.12</version>\r\n			<scope>test</scope>\r\n		</dependency>\r\n		<!--数据库驱动 -->\r\n		<dependency>\r\n			<groupId>mysql</groupId>\r\n			<artifactId>mysql-connector-java</artifactId>\r\n			<version>5.1.48</version>\r\n		</dependency>\r\n		<!-- 数据库连接池 -->\r\n		<!-- https://mvnrepository.com/artifact/com.alibaba/druid -->\r\n		<dependency>\r\n			<groupId>com.alibaba</groupId>\r\n			<artifactId>druid</artifactId>\r\n			<version>1.1.20</version>\r\n		</dependency>\r\n\r\n		<!--Servlet - JSP -->\r\n		<dependency>\r\n			<groupId>javax.servlet</groupId>\r\n			<artifactId>servlet-api</artifactId>\r\n			<version>2.5</version>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>javax.servlet.jsp</groupId>\r\n			<artifactId>jsp-api</artifactId>\r\n			<version>2.2</version>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>javax.servlet</groupId>\r\n			<artifactId>jstl</artifactId>\r\n			<version>1.2</version>\r\n		</dependency>\r\n\r\n		<!--Mybatis -->\r\n		<dependency>\r\n			<groupId>org.mybatis</groupId>\r\n			<artifactId>mybatis</artifactId>\r\n			<version>3.5.2</version>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.mybatis</groupId>\r\n			<artifactId>mybatis-spring</artifactId>\r\n			<version>2.0.2</version>\r\n		</dependency>\r\n\r\n		<!--Spring -->\r\n		<dependency>\r\n			<groupId>org.springframework</groupId>\r\n			<artifactId>spring-webmvc</artifactId>\r\n			<version>5.1.9.RELEASE</version>\r\n		</dependency>\r\n		<dependency>\r\n			<groupId>org.springframework</groupId>\r\n			<artifactId>spring-jdbc</artifactId>\r\n			<version>5.1.9.RELEASE</version>\r\n		</dependency>\r\n\r\n		<!-- aop的包切面的包 -->\r\n	    <dependency>\r\n	      <groupId>org.aspectj</groupId>\r\n	      <artifactId>aspectjweaver</artifactId>\r\n	      <version>1.7.4</version>\r\n		</dependency>\r\n\r\n		<!-- lombok -->\r\n		<dependency>\r\n			<groupId>org.projectlombok</groupId>\r\n			<artifactId>lombok</artifactId>\r\n			<version>1.16.10</version>\r\n		</dependency>\r\n	</dependencies>\r\n	  <build>\r\n	    <finalName>ssmTest</finalName>\r\n	    <!-- 静态资源导出的问题 -->\r\n	    <resources>\r\n	        <resource>\r\n	            <directory>src/main/java</directory>\r\n	            <includes>\r\n	                <include>**/*.properties</include>\r\n	                <include>**/*.xml</include>\r\n	            </includes>\r\n	            <filtering>false</filtering>\r\n	        </resource>\r\n	        <resource>\r\n	            <directory>src/main/resources</directory>\r\n	            <includes>\r\n	                <include>**/*.properties</include>\r\n	                <include>**/*.xml</include>\r\n	            </includes>\r\n	            <filtering>false</filtering>\r\n	        </resource>\r\n	    </resources>\r\n	  </build>\r\n</project>\r\n```\r\n**1.需要手动创建web.xml\r\n2.需要将maven下的jar手动复制到lib下**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310164507219.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n### 配置框架的配置文件以及基本结构\r\n\r\n - com.myh.pojo\r\n - com.myh.service\r\n - con.myh.controller\r\n - com.myh.dao\r\n#### 创建实体类\r\n==com.myh.pojo.Books==\r\n```java\r\npackage com.myh.pojo;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Data;\r\nimport lombok.NoArgsConstructor;\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class Books {	\r\n	private int bookID;\r\n	private String bookName;\r\n	private int bookCounts;\r\n	private String detail;\r\n}\r\n```\r\n#### 创建实体对应的接口\r\n==com.myh.dao.BooksMapper==\r\n```java\r\npackage com.myh.dao;\r\nimport java.util.List;\r\nimport org.apache.ibatis.annotations.Param;\r\nimport com.myh.pojo.Books;\r\n\r\npublic interface BooksMapper {\r\n	\r\n	//增加一本书\r\n	int addBooks(Books books);\r\n	\r\n	//删除一本书\r\n	int deleteBooksById(@Param(\"bookID\") int id);\r\n	\r\n	//更新一本书\r\n	int updateBooks(Books books);\r\n	\r\n	//查询一本书\r\n	Books queryBooksById(@Param(\"bookID\") int id);\r\n	\r\n	//查询全部的书\r\n	List<Books> queryAllBooks();\r\n	\r\n	//根据书名查书籍\r\n	List<Books> querBookByName(@Param(\"bookName\") String bookName);\r\n}\r\n\r\n```\r\n#### 创建实体对应的接口文件（Mapper）\r\n==com.myh.dao.BooksMapper.xml==\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"com.myh.dao.BooksMapper\">\r\n	\r\n	<!-- 增加一本书 -->\r\n	<insert id=\"addBooks\" parameterType=\"Books\">\r\n		insert into ssmbuild.books(bookName,bookCounts,detail)\r\n		value(#{bookName},#{bookCounts},#{detail})\r\n	</insert>	\r\n	\r\n	<!-- 删除一本书 -->\r\n	<delete id=\"deleteBooksById\" parameterType=\"int\">\r\n		delete from ssmbuild.books where bookID=#{bookID}\r\n	</delete>\r\n	\r\n	<!-- 更新一本书 -->\r\n	<update id=\"updateBooks\" parameterType=\"Books\">\r\n		update ssmbuild.books set \r\n		bookName=#{bookName},bookCounts=#{bookCounts},detail=#{detail}\r\n		where bookID=#{bookID}\r\n	</update>\r\n	\r\n	<!--查询一本书 -->\r\n	<select id=\"queryBooksById\" parameterType=\"int\" resultType=\"Books\">\r\n		select * from ssmbuild.books where bookID=#{bookID}\r\n	</select>\r\n	\r\n	<!--查询全部的书 -->\r\n	<select id=\"queryAllBooks\" resultType=\"Books\">\r\n		select * from ssmbuild.books\r\n	</select>\r\n	\r\n	<!-- 根据书名查一本书 -->\r\n	<select id=\"querBookByName\" resultType=\"Books\">\r\n		select * from ssmbuild.books where bookName=#{bookName}\r\n	</select>\r\n</mapper> \r\n```\r\n#### 编写Service层的接口和实现类\r\n.==com.myh.service.BooksService==\r\n\r\n```java\r\npackage com.myh.service;\r\n\r\nimport java.util.List;\r\nimport org.apache.ibatis.annotations.Param;\r\nimport com.myh.pojo.Books;\r\n\r\npublic interface BooksService {\r\n	//增加一本书\r\n	int addBooks(Books books);\r\n	\r\n	//删除一本书\r\n	int deleteBooksById(@Param(\"bookID\") int id);\r\n	\r\n	//更新一本书\r\n	int updateBooks(Books books);\r\n	\r\n	//查询一本书\r\n	Books queryBooksById(@Param(\"bookID\") int id);\r\n	\r\n	//查询全部的书\r\n	List<Books> queryAllBooks();\r\n	\r\n	//根据书名查书籍\r\n	List<Books> querBookByName(@Param(\"bookName\") String bookName);\r\n}\r\n```\r\n==com.myh.service.BooksServiceImpl==\r\n\r\n```java\r\npackage com.myh.service;\r\n\r\nimport java.util.List;\r\nimport com.myh.dao.BooksMapper;\r\nimport com.myh.pojo.Books;\r\nimport com.myh.service.BooksService;\r\npublic class BooksServiceImpl implements BooksService{\r\n	\r\n	//service调dao层:组合Dao\r\n	private BooksMapper booksMapper;\r\n	public void setBooksMapper(BooksMapper booksMapper) {\r\n		this.booksMapper = booksMapper;\r\n	}\r\n\r\n	@Override\r\n	public int addBooks(Books books) {\r\n		return booksMapper.addBooks(books);\r\n	}\r\n\r\n	@Override\r\n	public int deleteBooksById(int id) {\r\n		return booksMapper.deleteBooksById(id);\r\n	}\r\n\r\n	@Override\r\n	public int updateBooks(Books books) {\r\n		return booksMapper.updateBooks(books);\r\n	}\r\n\r\n	@Override\r\n	public Books queryBooksById(int id) {\r\n		return booksMapper.queryBooksById(id);\r\n	}\r\n\r\n	@Override\r\n	public List<Books> queryAllBooks() {\r\n		return booksMapper.queryAllBooks();\r\n	}\r\n\r\n	@Override\r\n	public List<Books> querBookByName(String bookName) {\r\n		return booksMapper.querBookByName(bookName);\r\n	}\r\n}\r\n```\r\n### spring配置文件\r\n#### Spring整合dao层，数据源使用druid连接池；\r\n==spring-dao.xml==\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xmlns:context=\"http://www.springframework.org/schema/context\"\r\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\">\r\n\r\n	<!-- 1.关联数据库配置 文件 下面个标签是专门来引入配置文件的 加载druid.properties配置文件 -->\r\n	<context:property-placeholder location=\"classpath:druid.properties\" />\r\n	<!-- 2.连接池 dbcp 半自动 不能自动连接 c3p0 自动化操作（自动化加载配置文件，并且可以自动设置到对象中） druid hikari -->\r\n	<!-- 3.配置数据源 -->\r\n	<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\r\n		<!-- 注入属性 &useUnicode=true&characterEncoding=utf8 在Spring里各种符号要用它的的转义字符，上面我将“&”改写成“&amp;”后，报错消失 -->\r\n		<property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"></property>\r\n		<property name=\"url\" value=\"${jdbc.url}\"></property>\r\n		<property name=\"username\" value=\"${jdbc.username}\"></property>\r\n		<property name=\"password\" value=\"${jdbc.password}\"></property>\r\n		<property name=\"maxWait\" value=\"${jdbc.maxWait}\"></property>\r\n		<property name=\"maxActive\" value=\"${jdbc.maxActive}\"></property>\r\n		<property name=\"initialSize\" value=\"${jdbc.initialSize}\"></property>\r\n	</bean>\r\n	<!-- 3.sqlSessionFactory -->\r\n	<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\r\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\r\n		<!-- 绑定mybatis的配置文件 -->\r\n		<property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"></property>\r\n	</bean>\r\n	<!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 -->\r\n	<!--解释 ： https://www.cnblogs.com/jpfss/p/7799806.html -->\r\n	<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\r\n		<!-- 注入sqlSessionFactory -->\r\n		<property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\"/>\r\n		<!-- 给出需要扫描Dao接口包 -->\r\n		<property name=\"basePackage\" value=\"com.myh.dao\"/>\r\n	</bean> \r\n</beans>\r\n```\r\n#### Spring整合service层\r\n==spring-service.xml==\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xmlns:context=\"http://www.springframework.org/schema/context\"\r\n	xmlns:aop=\"http://www.springframework.org/schema/aop\"\r\n	xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n	xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd\r\n		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd\">\r\n	\r\n	\r\n	<!-- 1.扫描service下的包 -->\r\n	<context:component-scan base-package=\"com.myh.service\"></context:component-scan>\r\n	\r\n	<!-- 2.将我们的所有业务类，注入到spring，可以通过配置，或者注解实现 -->\r\n		<!-- 可以使用service注解 -->\r\n	<bean id=\"BooksServiceImpl\" class=\"com.myh.service.BooksServiceImpl\">\r\n		<property name=\"booksMapper\" ref=\"booksMapper\"></property>\r\n	</bean>  \r\n	\r\n	<!-- 3.声明式事务管理 -->\r\n	<bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\r\n		<!-- 注入数据源 -->\r\n		<property name=\"dataSource\" ref=\"dataSource\"></property>\r\n	</bean>\r\n	\r\n	<!-- 4.aop事务操作 -->\r\n	<!-- 结合aop实现事务的织入 -->\r\n	<!-- 配置事务通知 -->\r\n	<tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\">\r\n		<!-- 给哪些方法配置事务 -->\r\n		<!-- 配置事务的传播特性： new propagetion -->\r\n		<tx:attributes>\r\n			<tx:method name=\"add\" propagation=\"REQUIRED\"/>\r\n			<tx:method name=\"delete\" propagation=\"REQUIRED\"/>\r\n			<tx:method name=\"update\" propagation=\"REQUIRED\"/>\r\n			<tx:method name=\"query\" read-only=\"true\"/>\r\n			<tx:method name=\"*\" propagation=\"REQUIRED\"/>\r\n		</tx:attributes>\r\n	</tx:advice>\r\n	\r\n	<!-- 配置事务的切入 -->\r\n	<aop:config>\r\n		<aop:pointcut id=\"txPointCut\" expression=\"execution(* com.myh.dao.*.*(..))\"/>\r\n		<aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"txPointCut\"/>\r\n	</aop:config> \r\n</beans>\r\n```\r\n#### Spring整合mvc层\r\n==spring-mvc.xml==\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n	xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n	xmlns:context=\"http://www.springframework.org/schema/context\"\r\n	xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd\r\n		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\">\r\n	\r\n	<!-- 1.注解驱动  @ RequestMapping -->\r\n	<!--注解驱动，以使得访问路径与方法的匹配可以通过注解配置-->\r\n	<mvc:annotation-driven/>\r\n	\r\n	<!-- 2.静态资源过滤 -->\r\n	<!--静态页面，如html,css,js,images可以访问-->\r\n	<mvc:default-servlet-handler/>\r\n	\r\n	<!-- 3.扫描包:controller -->\r\n	<context:component-scan base-package=\"com.myh.controller\"></context:component-scan>\r\n	\r\n	<!-- 4.视图解析器 -->\r\n    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\r\n          id=\"internalResourceViewResolver\">\r\n        <!-- 前缀 -->\r\n        <property name=\"prefix\" value=\"/WEB-INF/jsp/\" />\r\n        <!-- 后缀 -->\r\n        <property name=\"suffix\" value=\".jsp\" />\r\n    </bean>\r\n	<!--扫描Controller,并将其生命周期纳入Spring管理\r\n	<context:annotation-config/>-->\r\n</beans>\r\n```\r\n#### web.xml\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n	xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\r\n	xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\r\n	id=\"WebApp_ID\" version=\"3.1\">\r\n	\r\n	<!-- 是否扫描注解 true 不扫描 metadata-complete=\"true\" 这是web.xml 3.0 才有 我是3.1 -->\r\n	<display-name>ssmbuild</display-name>\r\n	<!-- 加快tomcat启动速度 1.删除非root文件 这样加载文件减少 2.加一个约束 3.0以上才可以使用 意思是不扫描其它项目 -->\r\n	<absolute-ordering />\r\n\r\n	<!-- DispatchServlet -->\r\n	<servlet>\r\n		<servlet-name>springmvc</servlet-name>\r\n		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\r\n		<init-param>\r\n			<param-name>contextConfigLocation</param-name>\r\n			<param-value>classpath:applicationContext.xml</param-value>\r\n		</init-param>\r\n		<load-on-startup>1</load-on-startup>\r\n	</servlet>\r\n	<servlet-mapping>\r\n		<servlet-name>springmvc</servlet-name>\r\n		<url-pattern>/</url-pattern>\r\n	</servlet-mapping>\r\n	<!-- 乱码过滤 -->\r\n	<filter>\r\n		<filter-name>encodingFilter</filter-name>\r\n		<filter-class> org.springframework.web.filter.CharacterEncodingFilter</filter-class>\r\n		<init-param>\r\n			<param-name>encoding</param-name>\r\n			<param-value>utf-8</param-value>\r\n		</init-param>\r\n	</filter>\r\n	<filter-mapping>\r\n		<filter-name>encodingFilter</filter-name>\r\n		<url-pattern>/*</url-pattern>\r\n	</filter-mapping>\r\n	<!-- session过期时间   默认好像是30-->\r\n	<session-config>\r\n		<session-timeout>15</session-timeout>\r\n	</session-config>\r\n	<!-- 默认访问页面 -->\r\n	<welcome-file-list>\r\n		<welcome-file>index.html</welcome-file>\r\n		<welcome-file>index.htm</welcome-file>\r\n		<welcome-file>index.jsp</welcome-file>\r\n		<welcome-file>default.html</welcome-file>\r\n		<welcome-file>default.htm</welcome-file>\r\n		<welcome-file>default.jsp</welcome-file>\r\n	</welcome-file-list>\r\n</web-app>\r\n```\r\n####  Mybatis配置文件\r\n==mybatis-config.xml==\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>	\r\n	<!-- 配置数据源，交给spring -->\r\n	<!-- 在进行dao的时候取别名 -->\r\n	<typeAliases>\r\n		<package name=\"com.myh.pojo\"/>\r\n	</typeAliases>	\r\n	<mappers>\r\n		<!-- 配置文件和接口名一样使用class 否则使用resource -->\r\n		<mapper class=\"com.myh.dao.BooksMapper\" />\r\n	</mappers>\r\n</configuration>\r\n```\r\n#### applicationContext.xml\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\r\n	<import resource=\"classpath:spring-dao.xml\"/>\r\n	<import resource=\"classpath:spring-service.xml\"/>\r\n	<import resource=\"classpath:spring-mvc.xml\"/>\r\n</beans>\r\n```\r\n#### druid配置信息\r\n\r\n```java\r\njdbc.driverClassName=com.mysql.jdbc.Driver\r\njdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&useUnicode=true&characterEncoding=utf8\r\n##useUnicode=true&characterEncoding=utf8 解决往数据库写入汉字乱码的问题\r\njdbc.username=root\r\njdbc.password=123456\r\n# 	初始化连接数目\r\njdbc.initialSize=5\r\n#  	最大连接池数量\r\njdbc.maxActive=10\r\n# 	获取连接时最大等待时间，单位毫秒。\r\njdbc.maxWait=3000\r\n```\r\n### -----------------------------------------------------------------------------------------------\r\n**到这里配置文件以及基本完成了 开始编写controller**\r\n### controller层代码编写\r\n==com.myh.controller.BooksController==\r\n\r\n```java\r\npackage com.myh.controller;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.beans.factory.annotation.Qualifier;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.ui.Model;\r\nimport org.springframework.web.bind.annotation.PathVariable;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\n\r\nimport com.myh.pojo.Books;\r\nimport com.myh.service.BooksService;\r\n\r\n/*\r\n**2020年3月8日--下午5:18:11\r\n**@version:\r\n**莫耀华:\r\n**@Description:\r\n*/\r\n@Controller\r\n@RequestMapping(\"/books\")\r\npublic class BooksController {\r\n		\r\n	@Autowired\r\n	@Qualifier(\"BooksServiceImpl\")\r\n	private BooksService booksService;\r\n	\r\n	//查询全部的书籍，并且返回到一个书籍展示页面\r\n	@RequestMapping(\"/allBook\")\r\n	public String list(Model model) {\r\n		List<Books> list = new ArrayList<Books>();\r\n		list= booksService.queryAllBooks();\r\n		model.addAttribute(\"list\", list);\r\n		return \"allBook\";\r\n	}\r\n	\r\n	//跳转到增加书籍页面\r\n	@RequestMapping(\"/toAddBookPage\")\r\n	public String toAddBookPage() {\r\n		return \"toAddBookPage\";\r\n	}\r\n	\r\n	//添加书籍的请求\r\n	@RequestMapping(\"/addBook\")\r\n	public String addBook(Books books) {\r\n		int addBooks = booksService.addBooks(books);\r\n		return \"redirect:/books/allBook\";//重定向首页\r\n	}\r\n	\r\n	//跳转到修改页面\r\n	@RequestMapping(\"/toUpdatePage\")\r\n	public String toUpdatePage(int bookID,Model model) {\r\n		Books queryBooksById = booksService.queryBooksById(bookID);\r\n		model.addAttribute(\"QBook\", queryBooksById);\r\n		return \"toUpdatePage\";\r\n	}\r\n	\r\n	//修改书籍的请求\r\n	@RequestMapping(\"/updatePage\")\r\n	public String updatePage(Books books) {\r\n		booksService.updateBooks(books);\r\n		return \"redirect:/books/allBook\";//重定向首页\r\n	}\r\n	\r\n	//刪除书籍  使用风格\r\n	@RequestMapping(\"/deleteBook/{bookID}\")\r\n	public String deleteBook(@PathVariable(\"bookID\") int id) {\r\n		booksService.deleteBooksById(id);\r\n		return \"redirect:/books/allBook\";//重定向首页\r\n	}\r\n	\r\n	//查询书籍\r\n	@RequestMapping(\"/queryBook\")\r\n	public String queryBook(String queryBookname,Model model) {\r\n		List<Books> list = new ArrayList<Books>(); \r\n		list=booksService.querBookByName(queryBookname);\r\n		if(list.isEmpty()) {\r\n			//是空，则返回全部数据 提示信息\r\n			list=booksService.queryAllBooks();\r\n			model.addAttribute(\"error\", \"为查到该书籍！\");\r\n		}\r\n		model.addAttribute(\"list\", list);\r\n		return \"allBook\";\r\n	}\r\n} \r\n```\r\n### 开始测试\r\n#### WebContent的目录结构以及内容\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310172100530.jpg)\r\n==index.jsp==\r\n```java\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n	pageEncoding=\"UTF-8\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>登入</title>\r\n<style type=\"text/css\">\r\na {\r\n	text-decoration: none;\r\n	colro: black;\r\n	font-size: 18px;\r\n}\r\n\r\nh3 {\r\n	width: 180px;\r\n	height: 38px;\r\n	margin: 100px auto;\r\n	text-align: center;\r\n	line-height: 38px;\r\n	background-color: deepskyblue;\r\n	border-radius: 5px;\r\n}\r\n</style>\r\n</head>\r\n<body>\r\n	<h3>\r\n		<a href=\"${pageContext.request.contextPath}/books/allBook\">进入书籍页面</a>\r\n	</h3>\r\n</body>\r\n</html>\r\n```\r\n==allBook.jsp==\r\n```java\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n	pageEncoding=\"UTF-8\"%>\r\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>展示书籍</title>\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\">\r\n</head>\r\n<body>\r\n	<div class=\"container\">\r\n\r\n		<div class=\"row clearfix\">\r\n			<div class=\"col-md-12 column\">\r\n				<div class=\"page-header\">\r\n					<h1>\r\n						<small>书籍列表--显示所有书籍</small>\r\n					</h1>\r\n				</div>\r\n			</div>\r\n			<div class=\"row\">\r\n				<div class=\"col-md-4 column\">\r\n					<a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/books/toAddBookPage\">新增书籍</a>\r\n					<a class=\"btn btn-primary\" href=\"${pageContext.request.contextPath}/books/allBook\">显示全部书籍</a>\r\n				</div>\r\n				<div class=\"col-md-8 column\">\r\n					<!-- 查询书籍 -->\r\n					<form action=\"${pageContext.request.contextPath}/books/queryBook\" method=\"post\" class=\"form-inline\" style=\"float: right;\">\r\n						<span style=\"color:red;font-weight: bold;\">${error }</span>\r\n						<input type=\"text\" name=\"queryBookname\" class=\"form-control\" placeholder=\"请输入书籍名称\"/>\r\n						<input  type=\"submit\" value=\"查询\"  class=\"btn btn-primary\"/>\r\n					</form>\r\n				</div>\r\n			</div>\r\n			\r\n		</div>\r\n\r\n		<div class=\"row clearfix\">\r\n			<div class=\"col-md-12 column\">\r\n				<table class=\"table table-hover table-striped\">\r\n					<thead>\r\n						<tr>\r\n							<th>书籍编号</th>\r\n							<th>书籍名称</th>\r\n							<th>书籍数量</th>\r\n							<th>书籍详情</th>\r\n							<th>操作</th>\r\n						</tr>\r\n					</thead>\r\n					<!-- 从数据库查询数据 -->\r\n					<tbody>\r\n						<c:forEach var=\"books\" items=\"${list}\">\r\n							<tr>\r\n								<td>${books.bookID}</td>\r\n								<td>${books.bookName}</td>\r\n								<td>${books.bookCounts}</td>\r\n								<td>${books.detail}</td>\r\n								<td>\r\n									<a href=\"${pageContext.request.contextPath }/books//toUpdatePage?bookID=${books.bookID}\">修改</a>\r\n									&nbsp; | &nbsp; \r\n									<a href=\"${pageContext.request.contextPath }/books/deleteBook/${books.bookID}\">删除</a>\r\n								</td>\r\n							</tr>						\r\n						</c:forEach>\r\n					</tbody> \r\n					\r\n				</table>\r\n			</div>\r\n		</div>\r\n\r\n	</div>\r\n</body>\r\n<srcipt> </srcipt>\r\n</html>\r\n```\r\n==toAddBookPage.jsp==\r\n\r\n```java\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n	pageEncoding=\"UTF-8\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>增加书籍</title>\r\n<link rel=\"stylesheet\"\r\n	href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\">\r\n</head>\r\n<body>\r\n	<div class=\"container\">\r\n\r\n		<div class=\"row clearfix\">\r\n			<div class=\"col-md-12 column\">\r\n				<div class=\"page-header\">\r\n					<h1>\r\n						<small>新增书籍</small>\r\n					</h1>\r\n				</div>\r\n			</div>\r\n		</div>\r\n		<form action=\"${pageContext.request.contextPath}/books/addBook\" method=\"post\">\r\n			<div class=\"form-group\">\r\n				<label >书籍名称：</label> \r\n				<input type=\"text\" name=\"bookName\" class=\"form-control\" placeholder=\"请输入书籍名称\" required=\"required\">\r\n			</div>\r\n			<div class=\"form-group\">\r\n				<label >书籍数量：</label> \r\n				<input type=\"text\"  name=\"bookCounts\" class=\"form-control\" placeholder=\"请输入书籍名称\" required=\"required\">\r\n			</div>\r\n			<div class=\"form-group\">\r\n				<label>书籍描述：</label> \r\n				<input type=\"text\" name=\"detail\" class=\"form-control\" placeholder=\"请输入书籍名称\" required=\"required\">\r\n			</div>\r\n			<div class=\"form-group\">\r\n				<input type=\"submit\" class=\"form-control\" value=\"添加\">\r\n			</div>		\r\n		</form>\r\n	</div>\r\n</body>\r\n</html>\r\n```\r\n==toUpdatePage.jsp==\r\n\r\n```java\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n    pageEncoding=\"UTF-8\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css\">\r\n<title>修改书籍页面</title>\r\n</head>\r\n<body>\r\n<div class=\"container\">\r\n\r\n		<div class=\"row clearfix\">\r\n			<div class=\"col-md-12 column\">\r\n				<div class=\"page-header\">\r\n					<h1>\r\n						<small>修改书籍</small>\r\n					</h1>\r\n				</div>\r\n			</div>\r\n		</div>\r\n		<form action=\"${pageContext.request.contextPath}/books/updatePage\" method=\"post\">\r\n			<input type=\"hidden\" name=\"bookID\" value=\"${QBook.bookID}\" />\r\n			<div class=\"form-group\">\r\n				<label >书籍名称：</label> \r\n				<input type=\"text\" name=\"bookName\" value=\"${QBook.bookName}\" class=\"form-control\" placeholder=\"请输入书籍名称\" required=\"required\">\r\n			</div>\r\n			<div class=\"form-group\">\r\n				<label >书籍数量：</label> \r\n				<input type=\"text\"  name=\"bookCounts\" value=\"${QBook.bookCounts}\" class=\"form-control\" placeholder=\"请输入书籍名称\" required=\"required\">\r\n			</div>\r\n			<div class=\"form-group\">\r\n				<label>书籍描述：</label> \r\n				<input type=\"text\" name=\"detail\" value=\"${QBook.detail}\" class=\"form-control\" placeholder=\"请输入书籍名称\" required=\"required\">\r\n			</div>\r\n			<div class=\"form-group\">\r\n				<input type=\"submit\" class=\"form-control\" value=\"修改\">\r\n			</div>		\r\n		</form>\r\n	</div>\r\n</body>\r\n</html>\r\n```\r\n### 测试样子\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310172546753.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310172608879.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**其它我就不test，本来就一个入门案例而已，如果你从上到下看完，应该也是可以做出和一样。这只是一个入门。我觉得我太详细了，算了算了，我也是第一次，各位慢慢来。**\r\n\r\n**在配置文件那一块，我很多都是懵的，我还是慢慢看吧，这就是当做一个练习或者基础框架的搭建。**\r\n\r\n**如有错误，请勿见怪，参考而已！切勿当真！**', '2019-12-01 03:36:46', '/images/1.jpg', '原创', '', '', '', 'ssm', '2020-06-27 08:01:38', '21', '3', '1', '8,7,6,10', '搭建简单ssm\n\n\n最近看完了spring和springmvc以及mybatis，对着视频敲完了所有代码，这次试试对着视频回顾一下ssm的搭建\n\n\n环境');
INSERT INTO `t_blog` VALUES ('1271647916540297216', '', '', '#   java上传文件\r\n##  1.知识点\r\n\r\n>1. 上传文件使用jar包\r\n> commons-fileupload-1.3.3.jar\r\n> commons-io-2.6.jar（依赖包）\r\n \r\n**manev下载地址**\r\n```xml\r\n	<!-- 文件上传 -->\r\n		<!-- https://mvnrepository.com/artifact/commons-io/commons-io -->\r\n		<dependency>\r\n			<groupId>commons-io</groupId>\r\n			<artifactId>commons-io</artifactId>\r\n			<version>2.6</version>\r\n		</dependency>\r\n		<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->\r\n		<dependency>\r\n			<groupId>commons-fileupload</groupId>\r\n			<artifactId>commons-fileupload</artifactId>\r\n			<version>1.3.3</version>\r\n		</dependency>\r\n```\r\n##  2.流程\r\n1. 判断提交上来的数据是否是上传表单的数据\r\n2. 创建上传文件的路径\r\n3. 创建DisFileItemFactory对象，处理文件上传路径或者大小限制的 磁盘的工厂对象\r\n4. 2.获取servletFileUpload\r\n5. .处理上传的文件\r\n6. 处理消息，跳转页面\r\n##  3.servlet代码\r\n\r\n```java\r\npackage com.myh.uploadfile;\r\n\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStream;\r\nimport java.util.List;\r\nimport java.util.UUID;\r\n\r\nimport javax.servlet.ServletContext;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.commons.fileupload.FileItem;\r\nimport org.apache.commons.fileupload.FileUploadException;\r\nimport org.apache.commons.fileupload.ProgressListener;\r\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\r\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\r\n\r\n@WebServlet(\"/upload.do\")\r\npublic class UploadFile extends HttpServlet {\r\n	@Override\r\n	protected void doPost(HttpServletRequest request, HttpServletResponse response)\r\n			throws ServletException, IOException {\r\n		ServletContext servletContext = request.getServletContext();\r\n		// 判断上传的文件是普通表单还是带文件的的表单\r\n		// 判断提交上来的数据是否是上传表单的数据\r\n		if (!ServletFileUpload.isMultipartContent(request)) {\r\n			return; // 弹栈 联想到jvm运行原理 终止方法运行 说明这个是普通表单 直接返回\r\n		}\r\n		// 创建上传文件的保存路径，建议在WEB-INF下面，安全，用户无法直接访问上传的文件\r\n		String uploadPath = servletContext.getRealPath(\"/WEB-INF/upload\");\r\n		File uploadFile = new File(uploadPath);\r\n		// 如果目录不存在 则创建目录\r\n		if (!uploadFile.exists()) {\r\n			uploadFile.mkdirs(); // 创建这个目录\r\n		}\r\n		// 缓冲，临时文件\r\n		// 临时文件目录，假如问价超过了预期的大小，我们就把他放到一个临时文件中，过几天自动删除，或者提醒用户转存为永远（qq大于300M就有提示）\r\n		String tmpPath = servletContext.getRealPath(\"/WEB-INF/tmp\");\r\n		File tmpFile = new File(tmpPath);\r\n		// 如果目录不存在 则创建目录\r\n		if (!tmpFile.exists()) {\r\n			tmpFile.mkdirs(); // 创建这个目录\r\n		}\r\n		// 处理上传的文件，一般都需要通过流来获取，我们可以实现request.getInputStream(),原生态的文件上传流获取，十分麻烦\r\n		// 但是我们都建议使用Apache的文件上传组件来实现，common-fileupload，它需要依赖于common-io组件：\r\n		/*\r\n		 * ServletFileUpload 负责处理上传的文件数据，并将表单中每个输入项封装成一个FileItem对象，\r\n		 * 在使用ServletFileUpload对象解析请求时需要将DiskFileItemFactor对象\r\n		 * 所有，我们需要在进行解析工作前构造好DiskFileItemFactor对象，提高ServletFileUpload\r\n		 * 对象的构造方法或者setFileFactory方法设置ServletFileUpload对象的fileItemFactory属性\r\n		 */\r\n		// 1.创建DisFileItemFactory对象，处理文件上传路径或者大小限制的 磁盘的工厂对象\r\n		DiskFileItemFactory factory = getDiskFileItemFactory(tmpFile);\r\n		// 2.获取servletFileUpload\r\n		ServletFileUpload upload = getServletFileUpload(factory);\r\n		// 3.处理上传的文件\r\n		// 把前端请求解析 ，封装成一个FileItem对象 是需要从servletFileupload对象获取\r\n		String msg = null;\r\n		msg = getUploadParseRequest(upload, request, uploadPath);\r\n		request.setAttribute(\"msg\", msg);\r\n		request.getRequestDispatcher(\"/uploadFile.jsp\").forward(request, response);\r\n	}\r\n\r\n	@Override\r\n	protected void doGet(HttpServletRequest request, HttpServletResponse response)\r\n			throws ServletException, IOException {\r\n		doPost(request, response);\r\n	}\r\n\r\n	public static DiskFileItemFactory getDiskFileItemFactory(File tmpFile) {\r\n		DiskFileItemFactory factory = new DiskFileItemFactory();\r\n		// 通过这个工厂设置一个缓存区，当上传的文件大于这个换成区的时候，讲他放到临时文件中\r\n		factory.setSizeThreshold(1024 * 1024); // 缓存大小为1M\r\n		factory.setRepository(tmpFile);// 临时目录的保存目录 需要一个file\r\n		return factory;\r\n	}\r\n\r\n	public static ServletFileUpload getServletFileUpload(DiskFileItemFactory factory) {\r\n		ServletFileUpload upload = new ServletFileUpload(factory);\r\n		upload.setProgressListener(new ProgressListener() {\r\n			// 监听文件上传进度\r\n			@Override\r\n			public void update(long pBytesRead, long pContentLength, int pItems) {\r\n				// pBytesRead :已经读取到的文件大小\r\n				// pContentLength：文件大小\r\n				System.out.println(\"总大小：\" + pContentLength + \" 已上传：\" + pBytesRead);\r\n			}\r\n		});\r\n		// 处理乱码问题 //不设置 欧默认值\r\n		upload.setHeaderEncoding(\"UTF-8\");\r\n		// 设置单个文件的最大值\r\n		upload.setFileSizeMax(1024 * 1024 * 10);\r\n		// 设置总共能够上传的文件的大小\r\n		// 1024=1kb*1024 1M*10=10M\r\n		upload.setSizeMax(1024 * 1024 * 20); // 20M 1024kb\r\n		return upload;\r\n	}\r\n\r\n	public static String getUploadParseRequest(ServletFileUpload upload, HttpServletRequest request,\r\n			String uploadPath) {\r\n		String msg = null;\r\n		List<FileItem> fileItems;\r\n		try {\r\n			fileItems = upload.parseRequest(request);\r\n			// fileItem 代表每一个表单对象\r\n			for (FileItem fileItem : fileItems) {\r\n				// 判断上传的文件是普通的表单还是带文件的表单 文件表单\r\n				if (!fileItem.isFormField()) {\r\n					// ======================处理文件========================//\r\n					String uploadFileName = fileItem.getName();\r\n					System.out.println(\"上传文件名：\" + uploadFileName);\r\n					// 可能存在文件名不合法的情况\r\n					if (uploadFileName == null || (\"\").equals(uploadFileName.trim())) {\r\n						continue;\r\n					}\r\n					// 获取上传的文件名 /images/girl/xiaobao.png\r\n					String fileName = uploadFileName.substring(uploadFileName.indexOf(\"/\") + 1);\r\n					System.out.println(\"上传信息：\" + fileName);\r\n					// 获取上传的文件的后缀名\r\n					String fileExName = uploadFileName.substring(uploadFileName.indexOf(\".\") + 1);\r\n					/*\r\n					 * 如歌文件后缀名 fileExName 不是我们所需要的 就之间return ，不处理 ，告诉用户类型不对\r\n					 */\r\n					// 可以使用UUID（唯一识别的通用码），保证文件名的唯一：\r\n					// UUID.randomUUID(),随机生一个唯一的识别的通用，码\r\n					// 网络传输中的东西，都需要序列化\r\n					// pojo ，实体类 ，如果想要在多个电脑上运行，传输===》需要把对象序列化了\r\n					// jni =java Native interface java本地化接口\r\n					// implements serializable ：标记接口 （区分函数式接口） jvm --》java栈 native --》\r\n					String uuidPath = UUID.randomUUID().toString();\r\n					// ======================存放地址========================//\r\n					// 存到那？uploadPath()\r\n					// 文件真实存在的路径 realpath\r\n					String realPath = uploadPath + \"/\" + uuidPath;\r\n					// 给每一个文件创建一个对应的文件夹\r\n					File realPathFile = new File(realPath);\r\n					if (!realPathFile.exists()) {\r\n						realPathFile.mkdirs();\r\n					}\r\n					// ========================判断文件大小===========================//\r\n					if (fileItem.getSize() > 1024 * 1024 * 10) {//10M\r\n						System.out.println(\"上传文件大小：\" + fileItem.getSize());\r\n						msg =  \"文件：\" + fileName + \"，上传文件大小超过限制大小：\" + upload.getFileSizeMax() + \"<br/>\";\r\n						continue;\r\n					}\r\n					// ======================文件传输完毕=====================//\r\n					// 获取文件上传的流\r\n					InputStream in = fileItem.getInputStream();\r\n					// 创建一个文件输出流\r\n					// replPath=真实文件夹\r\n					// 差一个文件;加上输出文件的名字+\"/\"+uuidFileName\r\n					FileOutputStream fos = new FileOutputStream(realPathFile + \"/\" + fileName);\r\n					// 创建一个缓存区\r\n					byte[] buffer = new byte[1024 * 1024];\r\n					int len = 0;\r\n					// 开始上传\r\n					while ((len = in.read(buffer)) > 0) {\r\n						fos.write(buffer, 0, len);\r\n					}\r\n					// 文件和数据库操作注意 关流\r\n					fos.close();\r\n					in.close();\r\n					msg = \"文件上传成功\";\r\n					fileItem.delete();// 上传成功 ，清理临时文件\r\n				}\r\n			}\r\n		} catch (Exception e) {\r\n			msg = \"上传文件大小超过限制<br/>\";\r\n			e.printStackTrace();\r\n		}\r\n		return msg;\r\n	}\r\n}\r\n\r\n```\r\n## 4.jsp\r\n\r\n```html\r\n<%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\"\r\n    pageEncoding=\"UTF-8\"%>\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=\"UTF-8\">\r\n<title>Insert title here</title>\r\n</head>\r\n<body>\r\n<!-- \r\n	通过表单\r\n	get 上传文件大小有限制\r\n	pots 没有限制\r\n	enctype=\"multipart/form-data\"\r\n -->\r\n	<form action=\"${pageContext.request.contextPath }/upload.do\" method=\"post\" enctype=\"multipart/form-data\">\r\n		<p>上传的人<input type=\"text\" name=\"author\"/></p>\r\n		<p><input type=\"file\" name=\"file1\"/></p>\r\n		<p><input type=\"file\" name=\"file2\"/></p>\r\n		<p><input type=\"submit\" value=\"提交\"/>${msg}</p> \r\n	</form>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 5.叙述\r\n\r\n>这里处理单个文件和多个文件都可以\r\n>我测试多次发现：\r\n>1.当上传的文件大小小于限制大小，文件可以上传成功\r\n>2.假设限制大小为10M，上传11M，会提示文件上传过大，跳转成功，控制台抛出异常，可以理解\r\n>3.假设限制大小为10M，上传50M，页面发生错误，跳转失败。\r\n## 6.照片演示\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200327221807896.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n上面的bug是经过测试出来的，怎么解决没想好，因为怎么其余ssm那里去解决的。\r\n\r\n\r\n\r\n/**************************************************************************************************************************************/\r\n### ssm上传文件\r\n1.导入jar包\r\n\r\n```xml\r\n<dependency>\r\n	<groupId>commons-io</groupId>\r\n	<artifactId>commons-io</artifactId>\r\n	<version>2.6</version>\r\n</dependency>\r\n<!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload -->\r\n<dependency>\r\n	<groupId>commons-fileupload</groupId>\r\n	<artifactId>commons-fileupload</artifactId>\r\n	<version>1.3.3</version>\r\n</dependency>\r\n	<dependency>\r\n	<groupId>javax.servlet</groupId>\r\n	<artifactId>javax.servlet-api</artifactId>\r\n	<version>3.1.0</version>\r\n</dependency>\r\n\r\n```\r\n2.**为了解决在eclipse中重新发布项目，导致上传文件被删除,使用在eclipse中的Servers中的server.xml文件加了一个虚拟映射路径**\r\n\r\n```xml\r\n<Context docBase=\"D:\\D\\tomcat\\apache-tomcat-8.5.47\\webapps\\ssm-anno-demo_upload\" path=\"/ssm-anno-demo_upload\" reloadable=\"true\"/>\r\n<Context docBase=\"ssm-anno-demo\" path=\"/ssm-anno-demo\" reloadable=\"true\" source=\"org.eclipse.jst.jee.server:ssm-anno-demo\"/>\r\n```\r\n**就是上传的文件不放在当前项目下，放在与项目同级的项目下，如何在添加一个虚拟映射就行了，以后需要访问的时候直接访问虚拟映射的路径**\r\n\r\n```java\r\n@RestController\r\npublic class UploadFileController {\r\n	\r\n//	@RequestParam(\"file\") 将name=file控件得到的文件封装成   CommonsMultipartFile 对象\r\n	\r\n	@PostMapping(\"/upload\")\r\n	public String fileUpload(@RequestParam(\"file\") CommonsMultipartFile file,HttpServletRequest request) throws Exception {\r\n		//获取文件名 ： file.getOriginalFilename\r\n		String uploadFilename = file.getOriginalFilename();\r\n		//如果文件名为空号  直接返回到首页\r\n		if(\"\".equals(uploadFilename)) {\r\n			return \"no\";\r\n		}\r\n		System.out.println(\"上传的文件名：\"+uploadFilename);\r\n		//上传文件路径保存设置\r\n		String path =\"D:\\\\D\\\\tomcat\\\\apache-tomcat-8.5.47\\\\webapps\\\\ssm-anno-demo_upload\";\r\n		//这里也可以获取项目路径 然后截取最后的// 从而获取项目路径的上一级目录，在创建文件加，但是要注意虚拟路径的配置\r\n		//如果路径不存在 就创建一个\r\n		File realPath = new  File(path);\r\n		System.out.println(\"realPath.exists()=\"+realPath.exists());\r\n		if(!realPath.exists()) {\r\n			realPath.mkdirs();\r\n		}\r\n		System.out.println(\"上传文件保存地址：\"+realPath);\r\n		InputStream is = file.getInputStream();\r\n		FileOutputStream os = new FileOutputStream(new File(realPath,uploadFilename));\r\n		//读取写出\r\n		int len=0;\r\n		byte[] buffer=new byte[1024];\r\n		while((len=is.read(buffer))!=-1) {\r\n			os.write(buffer,0,len);\r\n			os.flush();\r\n		}\r\n		os.close();\r\n		is.close();\r\n		System.out.println(\"ok\");\r\n		return \"ok\";\r\n	}\r\n	@PostMapping(\"/upload2\")\r\n	public String fileUpload2(@RequestParam(\"file\") CommonsMultipartFile file,HttpServletRequest request) throws Exception {\r\n		//获取文件名 ： file.getOriginalFilename\r\n		String uploadFilename = file.getOriginalFilename();\r\n		//如果文件名为空号  直接返回到首页\r\n		if(\"\".equals(uploadFilename)) {\r\n			return \"no\";\r\n		}//\r\n//		如果路径不存在 就创建一个\r\n		String path = request.getServletContext().getRealPath(\"/upload\");\r\n		File realPath = new  File(path);\r\n		System.out.println(\"realPath.exists()=\"+realPath.exists());\r\n		if(!realPath.exists()) {\r\n			realPath.mkdirs();\r\n		}\r\n		System.out.println(\"上传文件保存地址：\"+realPath);\r\n		file.transferTo(new File(realPath+\"/\"+file.getOriginalFilename()));\r\n		return \"ok\";\r\n	}\r\n}\r\n\r\n```\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604221533472.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**这样就可以解决重新部署项目，上传文件丢失的情况了。**\r\n\r\n此时访问上传文件的路径\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200604221728391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**当然，如果你就项目发布到linux服务器上，就不用这么做了，这个只是在开发的时候的问题，在linux只需要注意路径的即可\r\n \"/ \"   和     \"\\ \"   的区别**\r\n\r\n**仅供参考，不喜勿喷！谢谢!**', '2019-04-01 03:37:44', 'http://b.zol-img.com.cn/desk/bizhi/start/3/1372327522583.jpg', '原创', '', '', '', 'java上传文件', '2020-06-24 05:50:52', '17', '3', '1', '6,7', 'java上传文件\n1.知识点\n\n\n上传文件使用jar包\ncommons-fileupload-1.3.3.jar\ncommons-io-2.6.jar（依赖包）');
INSERT INTO `t_blog` VALUES ('1275670130210111488', '', '', '## 基础入门\r\n> 各种各样的sql需要写，什么分页啊，条件查询啊，真的太难了，之后发现有个mp，自动帮我们写sql，挺好用的，可能其他人喜欢jpa，可以都去了解一下。\r\n>\r\n\r\n\r\n==官网https://mp.baomidou.com/==\r\n\r\n### 简单使用\r\n#### 基本配置\r\n```properties\r\n# 配置日志 默认控制台 \r\nmybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\r\n# 配置逻辑删除 \r\n# 逻辑已删除值(默认为 1)\r\nmybatis-plus.global-config.db-config.logic-delete-value=1 \r\n# 逻辑未删除值(默认为 0)\r\nmybatis-plus.global-config.db-config.logic-not-delete-value=0 \r\nmybatis-plus.mapper-locations=classpath:mybatis/mapper/*Mapper.xml\r\n#是否使用 驼峰 默认使用\r\n# mybatis-plus.configuration.map-underscore-to-camel-case=false\r\n# 取别名\r\nmybatis-plus.type-aliases-package=com.myh.pojo\r\n```\r\n#### ORM映射关系\r\n````java\r\njava类	 	          								mysql数据库\r\njava.lang.Byte	           byte	                    TINYINT\r\njava.lang.Short	           short					SMALLINT\r\njava.lang.Integer	       integer				    INGEGER\r\njava.lang.Long			   long						BIGINT\r\njava.lang.Float			   float					FLOAT\r\njava.lang.Double	       double				    DOUBLE\r\njava.lang.BigDecimal	   big_decimal	            NUMERIC\r\njava.lang.Boolean	       boolean	                BIT\r\njava.lang.String	       string	                VARCHAR\r\njava.lang.Boolean	       yes_no	                CHAR(1)(\'Y\'或\'N\')\r\njava.lang.Boolean	       true_false	            CHAR(1)(‘Y’或\'N\')\r\njava.uitl.Date             date	    				DATE\r\njava.sql.Date			   date	    				DATE\r\njava.sql.Time			  time	                   TIME\r\njava.sql.Timestamp		  timestamp	           	   TIMESTAMP\r\njava.uitl.Calendar		  celendar	               TIMESTAMP\r\njava.uitl.Calendar		  calendar	               TIMESTAMP\r\njava.io.Serializable	  serializable	           VARBINARY/BLOB\r\njava.sql.Clob	          clob	                   CLOB\r\njava.sql.Blob			  blob	                   BLOB\r\njava.lang.Class			  class	                   VARCHAR\r\njava.uitl.Locale		  locale	               VARCHAR\r\njava.uitl.TimeZone		  timezone	               VARCHAR\r\njava.uitl.Currency		  currency	               VARCHAR\r\n``````\r\n\r\n#### target作用范围\r\n```java\r\n@Target(ElementType.TYPE)——接口、类、枚举、注解\r\n@Target(ElementType.FIELD)——字段、枚举的常量\r\n@Target(ElementType.METHOD)——方法\r\n@Target(ElementType.PARAMETER)——方法参数\r\n@Target(ElementType.CONSTRUCTOR) ——构造函数\r\n@Target(ElementType.LOCAL_VARIABLE)——局部变量\r\n@Target(ElementType.ANNOTATION_TYPE)——注解\r\n@Target(ElementType.PACKAGE)——包\r\n\r\n@Retention：注解的保留位置\r\n\r\nRetentionPolicy.SOURCE:这种类型的Annotations\r\n只在源代码级别保留,编译时就会被忽略,在class字节码文件中不包含。\r\nRetentionPolicy.CLASS:这种类型的Annotations编译时被保留,默认的保留策略,\r\n在class文件中存在,但JVM将会忽略,运行时无法获得。\r\n\r\nRetentionPolicy.RUNTIME:这种类型的Annotations将被JVM保留,\r\n所以他们能在运行时被JVM或其他使用反射机制的代码所读取和使用。\r\n\r\n@Document：说明该注解将被包含在javadoc中\r\n@Inherited：说明子类可以继承父类中的该注解\r\n```\r\n#### 快速开始\r\n\r\n> 创建springboot的链接 eclipse有时候超时  可以用下面这个\r\n>  https://start.aliyun.com/\r\n\r\n\r\n1.创建数据库\r\n```sql\r\ncreate database mybats_plus charactor set utf8\r\n```\r\n2.创建user表\r\n\r\n```sql\r\nDROP TABLE IF EXISTS user;\r\nCREATE TABLE user\r\n(\r\n	id BIGINT(20) NOT NULL COMMENT \'主键ID\',\r\n	name VARCHAR(30) NULL DEFAULT NULL COMMENT \'姓名\',\r\n	age INT(11) NULL DEFAULT NULL COMMENT \'年龄\',\r\n	email VARCHAR(50) NULL DEFAULT NULL COMMENT \'邮箱\',\r\n	PRIMARY KEY (id)\r\n);\r\n\r\n//真实开发\r\n//version 乐观锁\r\n//delete 逻辑删除\r\n//gmt_create\r\n//gmt_modified\r\nDELETE FROM user;\r\n\r\nINSERT INTO user (id, name, age, email) VALUES\r\n(1, \'Jone\', 18, \'test1@baomidou.com\'),\r\n(2, \'Jack\', 20, \'test2@baomidou.com\'),\r\n(3, \'Tom\', 28, \'test3@baomidou.com\'),\r\n(4, \'Sandy\', 21, \'test4@baomidou.com\'),\r\n(5, \'Billie\', 24, \'test5@baomidou.com\');\r\n```\r\n依赖\r\n```xml\r\n<dependency>\r\n		<groupId>org.springframework.boot</groupId>\r\n		<artifactId>spring-boot-starter-web</artifactId>\r\n	</dependency>\r\n\r\n	<!-- 数据库 -->\r\n	<dependency>\r\n		<groupId>mysql</groupId>\r\n		<artifactId>mysql-connector-java</artifactId>\r\n	</dependency>\r\n	\r\n	<!-- mybatis-plus 自己开发的-->\r\n	<dependency>\r\n		<groupId>com.baomidou</groupId>\r\n		<artifactId>mybatis-plus-boot-starter</artifactId>\r\n		<version>3.0.5</version>\r\n	</dependency>\r\n\r\n	<dependency>\r\n		<groupId>org.springframework.boot</groupId>\r\n		<artifactId>spring-boot-devtools</artifactId>\r\n		<scope>runtime</scope>\r\n		<optional>true</optional>\r\n	</dependency>\r\n	<dependency>\r\n		<groupId>org.projectlombok</groupId>\r\n		<artifactId>lombok</artifactId>\r\n		<optional>true</optional>\r\n	</dependency>\r\n```\r\n==mybatis和mybatisplus不要同时导入  会有依赖版本问题 导入mybatisplus就行了==\r\n配置文件\r\n```java\r\n5和8有区别  8需要时区 5驱动不同\r\nserver.port=8080\r\nspring.datasource.username=root\r\nspring.datasource.password=123456\r\nspring.datasource.url=jdbc:mysql://localhost:3306/mybatis_plus?\r\n	serverTimezone=UTC&useSSL=false&useUnicode=true&characterEncoding=utf8\r\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n```\r\n传统方式pojo -dao(连接mybatispuls ，配置mapper.xml文件) -service -controller\r\n现在方式：pojo mapper 使用\r\n\r\n```java\r\n@Repository\r\n@Mapper //在启动类中取扫描\r\npublic interface UserMapper extends BaseMapper<User> {\r\n	//所有的crud操作都已经完成编写了\r\n	//你不需要像以前配置一大堆文件了\r\n}\r\n```\r\nTest\r\n\r\n```java\r\n@SpringBootTest\r\nclass Mybatisplus01QuickstartApplicationTests {	\r\n	@Autowired\r\n	private UserMapper userMapper;	\r\n	@Test\r\n	void contextLoads() {\r\n		//参数是一个wapper 条件构造器 \r\n		//查询全部用户\r\n		List<User> list= userMapper.selectList(null);\r\n		list.forEach(System.out::println);\r\n	}\r\n}\r\n```\r\n#### mybatis-plus的字段映射关系\r\n``在mybatis-plus中，默认开启驼峰命名``\r\n\r\n```java\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@TableName(value = \"user\")\r\npublic class User {\r\n	//对应数据库的主件 uuid 自增id 雪花算法 redis zookeeper\r\n	//默认  全局唯一id  ID_WORKER\r\n	//自增AUTO 数据库也有变成自增\r\n	@TableId(type = IdType.AUTO)\r\n    private Long id;\r\n//  private String name;\r\n    private String userName;\r\n    private Integer age;\r\n    private String email;\r\n    \r\n    @TableField(fill = FieldFill.INSERT)\r\n    private Date gmtCreate;\r\n    @TableField(fill = FieldFill.INSERT_UPDATE)\r\n    private Date gmt_modified;\r\n}\r\n//  如果你的字段类型为userName，那么在数据库查询的时候映射的时候\r\n//  默认映射为user_name 如果此时你的数据库字段为userName就会报错\r\n//  也就是他自动将userName转化为 user_name \r\n//  所以此时你的数据库字段应该为 user_name\r\n//  也就是只在俩种情况会映射成功\r\n//1.字段名和数据库一样 映射成功\r\n//2.驼峰命名规则也会成功\r\n```\r\n``关闭驼峰命名``\r\n\r\n```java\r\nmybatis-plus:\r\n  configuration:\r\n    map-underscore-to-camel-case: false\r\n# 是否开启自动驼峰命名规则（camel case）映射，\r\n即从经典数据库列名 A_COLUMN（下划线命名） \r\n到经典 Java 属性名 aColumn（驼峰命名） 的类似映射\r\n```\r\n``spring中``\r\n\r\n```xml\r\n<!-- MP 全局配置 -->\r\n<bean id=\"globalConfig\" class=\"com.baomidou.mybatisplus.entity.GlobalConfiguration\">\r\n    <!-- 全局的主键策略 -->\r\n    <property name=\"idType\" value=\"0\"/>\r\n    <!--映射数据库下划线字段名到数据库实体类的驼峰命名的映射-->\r\n    <property name=\"dbColumnUnderline\" value=\"flase\"/>\r\n</bean>\r\n```\r\n#### 配置日志\r\n\r\n```properties\r\n# 配置日志 默认控制台\r\nmybatis-plus.configuration.log-impl=\r\n	org.apache.ibatis.logging.stdout.StdOutImpl\r\n```\r\n#### 缓存测试\r\n\r\n```java\r\nList<User> list= userMapper.selectList(null);\r\nList<User> list1= userMapper.selectList(null);\r\n//没有缓存\r\n```\r\n```properties\r\nCreating a new SqlSession\r\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@655a01d8] was not registered for synchronization because synchronization is not active\r\nJDBC Connection [HikariProxyConnection@935599808 wrapping com.mysql.cj.jdbc.ConnectionImpl@35a0e495] will not be managed by Spring\r\n==>  Preparing: SELECT id,name,age,email FROM user \r\n==> Parameters: \r\n<==    Columns: id, name, age, email\r\n<==        Row: 1, Jone, 18, test1@baomidou.com\r\n<==        Row: 2, Jack, 20, test2@baomidou.com\r\n<==        Row: 3, Tom, 28, test3@baomidou.com\r\n<==        Row: 4, Sandy, 21, test4@baomidou.com\r\n<==        Row: 5, Billie, 24, test5@baomidou.com\r\n<==      Total: 5\r\nClosing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@655a01d8]\r\nCreating a new SqlSession\r\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@770beef5] was not registered for synchronization because synchronization is not active\r\nJDBC Connection [HikariProxyConnection@1842476600 wrapping com.mysql.cj.jdbc.ConnectionImpl@35a0e495] will not be managed by Spring\r\n==>  Preparing: SELECT id,name,age,email FROM user \r\n==> Parameters: \r\n<==    Columns: id, name, age, email\r\n<==        Row: 1, Jone, 18, test1@baomidou.com\r\n<==        Row: 2, Jack, 20, test2@baomidou.com\r\n<==        Row: 3, Tom, 28, test3@baomidou.com\r\n<==        Row: 4, Sandy, 21, test4@baomidou.com\r\n<==        Row: 5, Billie, 24, test5@baomidou.com\r\n<==      Total: 5\r\nClosing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@770beef5]\r\nUser(id=1, name=Jone, age=18, email=test1@baomidou.com)\r\nUser(id=2, name=Jack, age=20, email=test2@baomidou.com)\r\nUser(id=3, name=Tom, age=28, email=test3@baomidou.com)\r\nUser(id=4, name=Sandy, age=21, email=test4@baomidou.com)\r\nUser(id=5, name=Billie, age=24, email=test5@baomidou.com)\r\n```\r\n\r\n> 开启二级缓存后，MP的baseMapper中提供的一系列Select方法不能命中二级缓存，只有自定义的方法才能命中二级缓存。\r\n> 官方：我们建议缓存放到 service 层，你可以自定义自己的 BaseServiceImpl 重写注解父类方法，继承自己的实现。\r\n#### curd\r\n##### 插入\r\n\r\n```java\r\n@Test\r\nvoid contextLoads1() {\r\n	//查询全部用户\r\n	User user=new User(); //自动生成id\r\n	user.setAge(3);\r\n	user.setEmail(\"1@qq.com\");\r\n	user.setName(\"A\");\r\n	userMapper.insert(user); //返回会影响的行数  id会自动回填 默认学号算法\r\n}\r\n//Creating a new SqlSession\r\n//SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@c269425] was not registered for //synchronization because synchronization is not active\r\n//JDBC Connection [HikariProxyConnection@1818236857 wrapping com.mysql.cj.jdbc.ConnectionImpl@4730e0f0] will not be managed by Spring\r\n//==>  Preparing: INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? ) \r\n//==> Parameters: 1264024876485070849(Long), A(String), 3(Integer), 1@qq.com(String)\r\n//<==    Updates: 1\r\n//Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@c269425]\r\n```\r\n主键生成策略\r\n``@TableId(type = IdType.AUTO)``\r\n\r\n```java\r\npublic enum IdType {\r\n    /**\r\n     * 数据库ID自增\r\n     */\r\n    AUTO(0),\r\n    /**\r\n     * 该类型为未设置主键类型\r\n     */\r\n    NONE(1),\r\n    /**\r\n     * 用户输入ID\r\n     * 该类型可以通过自己注册自动填充插件进行填充\r\n     */\r\n    INPUT(2),\r\n\r\n    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 */\r\n    /**\r\n     * 全局唯一ID (idWorker)\r\n     */\r\n    ID_WORKER(3),\r\n    /**\r\n     * 全局唯一ID (UUID)\r\n     */\r\n    UUID(4),\r\n    /**\r\n     * 字符串全局唯一ID (idWorker 的字符串表示)\r\n     */\r\n    ID_WORKER_STR(5);\r\n    private int key;\r\n    IdType(int key) {\r\n        this.key = key;\r\n    }\r\n}\r\n```\r\n##### 主键生成策\r\n\r\n> 默认 ID_WORKER 全局唯一id\r\n\r\n分布式系统唯一id生成：https://www.cnblogs.com/haoxinyue/p/5208136.html \r\n\r\n**雪花算法**：\r\n\r\n**snowﬂake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使\r\n用41bit作为 毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作\r\n为毫秒内的流水号（意味 着每个节点在每毫秒可以产生 4096 个 ID），后还有一个符号位，\r\n永远是0。可以保证几乎全球唯 一！**\r\n\r\n**主键自增\r\n1、实体类字段上 @TableId(type = IdType.AUTO)\r\n2、数据库字段一定要是自增！不然报错！\r\n3、再次测试插入即可！**\r\n##### 更新\r\n\r\n```java\r\n	@Test\r\n	void contextLoads2() {\r\n		//参数是一个wapper 条件构造器 \r\n		//查询全部用户\r\n		User user=new User();\r\n		user.setId(1L);\r\n		user.setAge(30);\r\n		user.setEmail(\"3@qq.com\");\r\n		user.setName(\"3\");\r\n		userMapper.updateById(user);\r\n	}\r\n// 在插入时 如果对象的字段的属性为null 那么在插入时不会出现在插入语句中\r\n```\r\n\r\n```java\r\nCreating a new SqlSession\r\nSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6614bd4b] was not registered for synchronization because synchronization is not active\r\nJDBC Connection [HikariProxyConnection@282812721 wrapping com.mysql.cj.jdbc.ConnectionImpl@6c6017b9] will not be managed by Spring\r\n==>  Preparing: UPDATE user SET name=?, age=?, email=? WHERE id=? \r\n==> Parameters: 3(String), 30(Integer), 3@qq.com(String), 1(Long)\r\n<==    Updates: 1\r\nClosing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@6614bd4b]\r\n```\r\n##### 自动填充\r\n创建时间 修改时间 ！这些操作一遍都是自动化完成的，不希望手动更新\r\n\r\n阿里巴巴开发手册：所有的数据库表：gmt_create  gmt_modified几乎所有的表都要配置上，查看数据修改时间\r\n\r\n新字段\r\n**gmt_create  \r\ngmt_modified  \r\n//CURRENT_TIMESTAMP 默认值 当前时间**\r\n\r\n```java\r\n@TableField(fill = FieldFill.UPDATE)\r\nprivate Data gmtCreate;\r\n@TableField(fill = FieldFill.INSERT_UPDATE)\r\nprivate Data gmtModified;\r\n```\r\n\r\n```java\r\npublic enum FieldFill {\r\n    /**\r\n     * 默认不处理\r\n     */\r\n    DEFAULT,\r\n    /**\r\n     * 插入填充字段\r\n     */\r\n    INSERT,\r\n    /**\r\n     * 更新填充字段\r\n     */\r\n    UPDATE,\r\n    /**\r\n     * 插入和更新填充字段\r\n     */\r\n    INSERT_UPDATE\r\n}\r\n```\r\n**编写处理器**\r\n\r\n```java\r\n@Component //要把处理器加入到ioc容器中\r\npublic class Myhander implements MetaObjectHandler{\r\n	@Override\r\n	public void insertFill(MetaObject metaObject) {\r\n		log.info(\"start insert insertFill\");\r\n		this.setFieldValByName(\"gmtCreate\", new Date(), metaObject);\r\n		this.setFieldValByName(\"gmtModified\", new Date(), metaObject);\r\n	}\r\n\r\n	@Override\r\n	public void updateFill(MetaObject metaObject) {\r\n		// TODO Auto-generated method stub\r\n		log.info(\"start insert updateFill\");\r\n		this.setFieldValByName(\"gmtModified\", new Date(), metaObject);\r\n	}\r\n}\r\n```\r\n##### 乐观锁\r\n\r\n> 乐观锁 : 故名思意十分乐观，它总是认为不会出现问题，无论干什么不去上锁！如果出现了问题， 再次更新值测试\r\n> 悲观锁：故名思意十分悲观，它总是认为总是出现问题，无论干什么都会上锁！再去操作！\r\n\r\n\r\n\r\n我们这里主要讲解 乐观锁机制！\r\n乐观锁实现方式：\r\n- 取出记录时，获取当前 version \r\n- 更新时，带上这个version \r\n- 执行更新时， set version = newVersion where version = oldVersion \r\n- 如果version不对，就更新失\r\n\r\n```java\r\n乐观锁：1、先查询，获得版本号 version = 1 \r\n\r\n-- A update user set name = \"kuangshen\", version = version + 1 \r\nwhere id = 2 and version = 1\r\n\r\n-- B 线程抢先完成，这个时候 version = 2，会导致 A 修改失败！ \r\nupdate user set name = \"kuangshen\", version = version + 1 \r\nwhere id = 2 and version = 1\r\n```\r\n1、给数据库中增加version字段！\r\n2、我们实体类加对应的字段\r\n\r\n```java\r\n//乐观锁\r\n@Version //乐观锁Version注解 \r\nprivate Integer version;\r\n```\r\n3、注册组件\r\n\r\n```java\r\n//扫描我们的 mapper 文件夹 \r\n@MapperScan(\"com.myh.mapper\")\r\n@EnableTransactionManagement \r\n//Spring Boot 使用事务非常简单，首先使用注解 @EnableTransactionManagement\r\n// 开启事务支持后，然后在访问数据库的Service方法上添加注解 @Transactional 便可\r\n@Configuration // 配置\r\npublic class MyMybatisPlusConfig {\r\n\r\n	// 注册乐观锁插件    \r\n	@Bean\r\n	public OptimisticLockerInterceptor optimisticLockerInterceptor() {\r\n		return new OptimisticLockerInterceptor();\r\n	}\r\n}\r\n```\r\n4、测试一下！\r\n\r\n```java\r\n//更新一个用户  测试乐观锁\r\n@Test\r\nvoid contextLoads3() {\r\n    //参数是一个wapper 条件构造器 \r\n    //查询全部用户\r\n    User user = userMapper.selectById(1L);\r\n    user.setName(\"1L\");\r\n    userMapper.updateById(user);\r\n}\r\n```\r\n\r\n```java\r\n==>  Preparing: UPDATE user SET name=?, age=?, email=?, gmt_create=?, gmt_modified=?, version=? WHERE id=? AND version=? \r\n==> Parameters: 1L(String), 301(Integer), 3@qq.com(String), 2020-05-23 19:12:05.0(Timestamp), 2020-06-12 09:53:10.931(Timestamp), 2(Integer), 1(Long), 1(Integer)\r\n<==    Updates: 1\r\n```\r\n失败的\r\n\r\n```java\r\n//更新一个用户  测试乐观锁  失败\r\n@Test\r\nvoid contextLoads4() {\r\n    // 线程 1 \r\n    User user = userMapper.selectById(1L);\r\n    user.setName(\"1L\");\r\n    // 模拟另外一个线程执行了插队操作 \r\n    User user2 = userMapper.selectById(1L);\r\n    user2.setName(\"2L\");\r\n    userMapper.updateById(user2);\r\n    userMapper.updateById(user);\r\n}\r\n```\r\n\r\n```javascript\r\n==>  Preparing: UPDATE user SET name=?, age=?, email=?, gmt_create=?, gmt_modified=?, version=? WHERE id=? AND version=? \r\n==> Parameters: 111(String), 301(Integer), 3@qq.com(String), 2020-05-23 19:12:05.0(Timestamp), 2020-06-12 09:56:11.94(Timestamp), 3(Integer), 1(Long), 2(Integer)\r\n<==    Updates: 1\r\n\r\n==>  Preparing: UPDATE user SET name=?, age=?, email=?, gmt_create=?, gmt_modified=?, version=? WHERE id=? AND version=? \r\n==> Parameters: 2L(String), 301(Integer), 3@qq.com(String), 2020-05-23 19:12:05.0(Timestamp), 2020-06-12 09:56:12.032(Timestamp), 3(Integer), 1(Long), 2(Integer)\r\n<==    Updates: 0\r\n```\r\n##### 查询操作\r\n\r\n```java\r\n//查询操作\r\n// 测试查询  查询一个\r\n@Test  \r\npublic void testSelectById(){ \r\n    User user = userMapper.selectById(1L);\r\n    System.out.println(user); \r\n//==>  Preparing: SELECT id,name,age,email,gmt_create,gmt_modified,version FROM user WHERE id=? \r\n//==> Parameters: 1(Long)\r\n//<==    Columns: id, name, age, email, gmt_create, gmt_modified, version\r\n//<==        Row: 1, 2L1, 301, 3@qq.com, 2020-05-23 11:12:05, 2020-06-12 02:07:07, 6\r\n//<==      Total: 1\r\n}\r\n\r\n//批量查询\r\n@Test  \r\npublic void testSelectByBatchId(){ \r\n    List<User> users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3)); \r\n    users.forEach(System.out::println);\r\n//==> Parameters: 1(Integer), 2(Integer), 3(Integer)\r\n//<==    Columns: id, name, age, email, gmt_create, gmt_modified, version\r\n//<==        Row: 1, 2L1, 301, 3@qq.com, 2020-05-23 11:12:05, 2020-06-12 02:07:07, 6\r\n//<==        Row: 2, 3, 301, 3@qq.com, 2020-05-23 11:12:05, 2020-06-12 01:38:36, 1\r\n//<==        Row: 3, Tom, 28, test3@baomidou.com, 2020-05-23 11:12:05, 2020-05-23 11:12:38, 1\r\n//<==      Total: 3\r\n}\r\n\r\n// 按条件查询之一使用map操作\r\n@Test\r\npublic void testSelectByBatchIds() {\r\n    HashMap<String, Object> map = new HashMap<>();// 自定义要查询  \r\n    map.put(\"name\", \"Billie\");\r\n    map.put(\"age\", 24);\r\n    userMapper.selectByMap(map);\r\n//==>  Preparing: SELECT id,name,age,email,gmt_create,gmt_modified,version FROM user WHERE name = ? AND age = ? \r\n//==> Parameters: Billie(String), 24(Integer)\r\n//<==    Columns: id, name, age, email, gmt_create, gmt_modified, version\r\n//<==        Row: 5, Billie, 24, test5@baomidou.com, 2020-05-23 11:12:05, 2020-05-23 11:12:38, 1\r\n//<==      Total: 1\r\n}\r\n```\r\n##### 分页查询\r\n1、原始的 limit 进行分页\r\n\r\n2、pageHelper 第三方插件\r\n\r\n3、MP 其实也内置了分页插件！\r\n\r\n> 如何使用？\r\n\r\n1、配置拦截器组件即可\r\n\r\n```java\r\n// 分页插件 \r\n@Bean \r\npublic PaginationInterceptor paginationInterceptor() {    \r\n    return  new PaginationInterceptor(); \r\n}\r\n```\r\n\r\n```java\r\n// 测试分页查询\r\n// 1.注册插件\r\n// 2.new Page\r\n// 3.开始查询\r\n\r\n// 按条件查询之一使用map操作\r\n// 测试分页查询\r\n@Test \r\npublic void testPage(){\r\n    //  参数一：当前页    \r\n    //  参数二：页面大小    \r\n    //  使用了分页插件之后，所有的分页操作也变得简单的！    \r\n    Page<User> page = new Page<>(2,5);\r\n    IPage<User> selectPage = userMapper.selectPage(page,null);\r\n    System.out.println(selectPage.getCurrent());  \r\n    System.out.println(selectPage.getPages());\r\n    System.out.println(selectPage.getSize());\r\n    System.out.println(selectPage.getTotal());\r\n    page.getRecords().forEach(System.out::println);\r\n    //	 	System.out.println(page.getTotal()); \r\n}\r\n```\r\n\r\n```java\r\n==>  Preparing: SELECT COUNT(1) FROM user \r\n==> Parameters: \r\n<==    Columns: COUNT(1)\r\n<==        Row: 9\r\n==>  Preparing: SELECT id,name,age,email,gmt_create,gmt_modified,version FROM user LIMIT 5,5 \r\n==> Parameters: \r\n<==    Columns: id, name, age, email, gmt_create, gmt_modified, version\r\n<==        Row: 1264024876485070849, A, 3, 1@qq.com, 2020-05-23 11:12:05, 2020-05-23 11:12:38, 1\r\n<==        Row: 1264024876485070850, A, 3, 1@qq.com, 2020-05-23 11:12:05, 2020-05-23 11:12:38, 1\r\n<==        Row: 1264024876485070851, 3, 30, 3@qq.com, 2020-06-10 09:02:20, 2020-05-23 03:33:16, 1\r\n<==        Row: 1264024876485070852, 3, 301, 3@qq.com, 2020-05-23 03:33:34, 2020-06-12 01:30:40, 1\r\n<==      Total: 4\r\n```\r\n##### 删除操作\r\n1、根据 id 删除记录\r\n\r\n```java\r\n// 测试删除 \r\n	@Test \r\n	public void testDeleteById(){\r\n		\r\n		int deleteById = userMapper.deleteById(1240620674645544965L);\r\n		System.out.println(deleteById);\r\n//==>  Preparing: DELETE FROM user WHERE id=? \r\n//==> Parameters: 1240620674645544965(Long)\r\n//<==    Updates: 0	\r\n	}\r\n	\r\n	// 通过id批量删除 \r\n	@Test \r\n	public void testDeleteBatchId(){\r\n		int deleteBatchIds = userMapper.deleteBatchIds(Arrays.asList(1264024876485070852L,1240620674645544962L)); \r\n		System.out.println(deleteBatchIds);\r\n//==>  Preparing: DELETE FROM user WHERE id IN ( ? , ? ) \r\n//==> Parameters: 1264024876485070852(Long), 1240620674645544962(Long)\r\n//<==    Updates: 1\r\n	}\r\n	// 通过map删除  动态sql\r\n	@Test \r\n	public void testDeleteMap() {\r\n		HashMap<String, Object> map = new HashMap<>(); \r\n		map.put(\"name\",\"1\");\r\n		map.put(\"age\",\"1\");\r\n		userMapper.deleteByMap(map);\r\n	}\r\n//==>  Preparing: DELETE FROM user WHERE name = ? AND age = ? \r\n//==> Parameters: 1(String), 1(String)\r\n//<==    Updates: 0\r\n```\r\n##### 逻辑删除\r\n**物理删除 ：从数据库中直接移除  \r\n逻辑删除 ：再数据库中没有被移除，而是通过一个变量来让他失效！ deleted = 0 => deleted = 1**\r\n\r\n1、在数据表中增加一个 deleted 字段\r\n2、实体类中增加属性\r\n\r\n```java\r\n@TableLogic //逻辑删除 \r\nprivate Integer deleted;\r\n```\r\n3、配置插件！\r\n```java\r\n# 配置逻辑删除 \r\n# 逻辑已删除值(默认为 1)\r\nmybatis-plus.global-config.db-config.logic-delete-value=1 \r\n# 逻辑未删除值(默认为 0)\r\nmybatis-plus.global-config.db-config.logic-not-delete-value=0 \r\n```\r\n4.注册插件\r\n\r\n```java\r\n// 逻辑删除组件！\r\n@Bean\r\npublic ISqlInjector sqlInjector() {\r\n    return new LogicSqlInjector();\r\n}\r\n```\r\n附件说明：\r\n- 逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。\r\n- 如果你需要再查出来就不应使用逻辑删除，而是以一个状态去表示。\r\n\r\n如： 员工离职，账号被锁定等都应该是一个状态字段，此种场景不应使用逻辑删除。\r\n\r\n- 若确需查找删除数据，如老板需要查看历史所有数据的统计汇总信息，请单独手写sql。\r\n##### 性能分析插件\r\n\r\n> 性能分析拦截器，用于输出每条 SQL 语句及其执行时间\r\n> \r\n> 该插件 3.2.0 以上版本移除推荐使用第三方扩展 执行SQL分析打印 功能\r\n\r\n我们在平时的开发中，会遇到一些慢sql。测试！ druid,,,,, \r\n\r\n作用：性能分析拦截器，用于输出每条 SQL 语句及其执行时间\r\n\r\n MP也提供性能分析插件，如果超过这个时间就停止运行！\r\n \r\n\r\n```java\r\n/**     * SQL执行效率插件     */ \r\n// 设置 dev test 环境开启，保证我们的效率 \r\n@Bean \r\n@Profile({\"dev\",\"test\"})\r\npublic PerformanceInterceptor performanceInterceptor() { \r\n    PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();\r\n    // ms设置sql执行的最大时间，如果超过了则不 执行1000ms   \r\n    performanceInterceptor.setMaxTime(10); \r\n    //		performanceInterceptor.setWriteInLog(true); //是否写入日志\r\n    // 是否格式化代码    \r\n    performanceInterceptor.setFormat(true);  \r\n    return performanceInterceptor; \r\n}\r\n```\r\n记住，要在SpringBoot中配置环境为dev或者 test 环境！\r\n\r\n```java\r\nspring.profiles.active=dev\r\n```\r\n2、测试使用！\r\n\r\n```java\r\n//查询操作\r\n// 测试查询  查询一个\r\n@Test  \r\n	public void testSelectById(){ \r\n		Book selectById = bookMapper.selectById(1);\r\n		System.out.println(selectById);\r\n	}\r\n//Time：66 ms - ID：com.myh.mapper.BookMapper.selectById\r\n```\r\n##### 多表 分页 模糊 自定义SQL\r\n\r\n> 自定义sql\r\n> 1.注解\r\n> 2.和mybatis一样的配置文件\r\n> 3.可以将mybatis-plsu 看成mybatis\r\n> 原因是只在mybatis上面只做增强 不做修改 \r\n> 但是多表还是要自己写sql，虽然自己写 但是模糊和分页已经做好了\r\n\r\ntest 多表分页条件查询\r\n\r\nUser实体类\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@TableName(value = \"user\")\r\npublic class User {\r\n	//对应数据库的主件 uuid 自增id 雪花算法 redis zookeeper\r\n	//默认  全局唯一id  ID_WORKER\r\n	//自增AUTO 数据库也有变成自增\r\n	@TableId(type = IdType.AUTO)\r\n    private Long id;\r\n	@TableField(value = \"name\")\r\n    private String name;\r\n    private Integer age;\r\n    private String email;\r\n    \r\n    @TableField(fill = FieldFill.INSERT)\r\n    private Date gmtCreate;\r\n    @TableField(fill = FieldFill.INSERT_UPDATE)\r\n    private Date gmt_modified;\r\n    \r\n    private Book book;\r\n    //乐观锁\r\n    //乐观锁Version注解  需要注册插件\r\n    @Version \r\n    private Integer version;\r\n    \r\n    @TableLogic //逻辑删除 \r\n    private Integer deleted;\r\n    \r\n    @TableField(el =\"order\",exist = false)\r\n    private Order order;\r\n    \r\n    @TableField(el =\"book\",exist = false)\r\n    private List<Book> bookList;\r\n}\r\n```\r\nBook实体类\r\n```java\r\n@Data\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@TableName(value = \"book\")\r\npublic class Book {\r\n	@TableId(value = \"id\")\r\n    private Long id;\r\n	@TableField(value = \"name\")\r\n    private String name;\r\n	@TableField(value = \"u_id\")\r\n    private Long uid;\r\n}\r\n```\r\nuser接口\r\n\r\n```java\r\n@Repository\r\n@Mapper\r\npublic interface UserMapper extends BaseMapper<User> {\r\n	//所有的crud操作都已经完成编写了\r\n	//你不需要像以前配置一大堆文件了\r\n//	@Select(\"select * from `user` u,book b where u.id=b.u_id \")\r\n//	public User getUserOne();\r\n	\r\n	public Page<User> findAllAndPage(IPage<User> page,@Param(Constants.WRAPPER) Wrapper<User> queryWrapper);\r\n}	\r\n```\r\nusermapper的xml\r\n\r\n```java\r\n	<resultMap type=\"com.myh.pojo.User\" id=\"userAll\">\r\n		<result column=\"uid\" property=\"id\"/>\r\n		<association property=\"book\" javaType=\"com.myh.pojo.Book\">\r\n			<result column=\"bid\" property=\"id\"/>\r\n		</association>\r\n	</resultMap>\r\n	\r\n	<select id=\"findAllAndPage\" resultMap=\"userAll\">\r\n		select u.id uid,b.id bid fROM user u INNER JOIN book b  on u.id=b.u_id ${ew.customSqlSegment}\r\n	</select>\r\n```\r\n我这里简单 ，所有只显示了bid和uid,需要啥就映射啥\r\n\r\n```java\r\n	//自定义SQL 分页\r\n	@Test \r\n	public void findAllAndPage() {\r\n		Page<User> page=new Page<User>(0, 5);\r\n		QueryWrapper<User> qw=new QueryWrapper<User>();\r\n		qw.eq(\"b.id\", \"1\").eq(\"u.id\", 1264024876485070850L);\r\n		Page<User> findAllAndPage = userMapper.findAllAndPage(page,qw);\r\n\r\n	} \r\n```\r\n\r\n```java\r\n==> Parameters: 1(String), 1264024876485070850(Long)\r\n<==    Columns: COUNT(1)\r\n<==        Row: 1\r\n==>  Preparing: select u.id uid,b.id bid fROM user u INNER JOIN book b on u.id=b.u_id WHERE b.id = ? AND u.id = ? LIMIT ?,? \r\n==> Parameters: 1(String), 1264024876485070850(Long), 0(Long), 5(Long)\r\n<==    Columns: uid, bid\r\n<==        Row: 12640\r\n//为什么有俩条呢？因为分页返回的Ipage，里面有个count，如果不需要级在分页的时候第三个参数变为false就行了\r\n```\r\nok到这里分页多和多表和添加查询就ok了。\r\n\r\n**总结**\r\n\r\n感想：mp解决的单表大部分操作，对于多表来说就不那么友好，但是，好在解决了其它的麻烦。\r\n\r\n比如分页和条件查询，它都帮我们解决了  多表的话建议使用内连接配合条件查询。感兴趣的话也可以去了解jpa。\r\n\r\n\r\n笔记来源：**https://space.bilibili.com/95256449/**\r\n\r\n我自己也适当的改了一点点。\r\n', '2020-06-24 06:00:35', '/images/2.jpg', '转载', '', '', '', 'mybatis-plus', '2020-06-24 06:00:35', '62', '6', '1', '7,1', '基础入门\n\n\n各种各样的sql需要写，什么分页啊，条件查询啊，真的太难了，之后发现有个mp，自动帮我们写sql，挺好用的，可能其他人喜欢jpa，可以都去了解一下。\n\n\n\n==官网https://mp.baomidou.');
INSERT INTO `t_blog` VALUES ('1275670539167334400', '', '', '## vscode基本配置\r\n### vs的基本配置\r\n\r\n> 1.适合于css，html，js\r\n\r\n1.下载vscode\r\n\r\n	下载地址：https://code.visualstudio.com\r\n\r\n2.下载完成后建议修改插件安装路径\r\n>   C:\\Users\\用户名\\.vscode\\extensions） 系统用户下面\r\n\r\n3.修改插件下载\r\n> 在原本的目标后加入--extensions-dir \"新的插件存储位置\"，例如\r\n\"D:\\Program Files\\Microsoft VS Code\\Code.exe\" --extensions-dir \"D:\\Program Files\\Microsoft VS Code\\extensions\"\r\n然后重新启动vscode即可\r\n\r\n4.修改完后插件地址为\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022612582685.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n```java\r\n	学习javascript\r\n	其实我个人喜欢用webstrom\r\n	但是听说vscode不错，所有正在学习使用vscode，个人感觉配置起来不是很简单 都是慢慢来吧，各位\r\n```\r\n		\r\n\r\n**对于英语不好的第一步肯定是汉化（不建议）**\r\n**1.Chinese (Simplified) Language Pack for Visual Studio Code**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226130316913.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**2.Live Server**\r\n	\r\n\r\n> 这个我还是挺喜欢的，当你修改源文件时，按下保存键，浏览器会自动刷新，不需要手动刷新，配合css非常好！可以的话建议在setting.json文件中修改：默认以google浏览器打开：\r\n> \"open-in-browser.default\": \"Chrome\",\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226130707889.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226130830828.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**3.open in browser**\r\n	\r\n\r\n> vscode不能再浏览器直接打开html，而该插件支持快捷键与鼠标右键快速在浏览器中打开html文件，支持自定义打开指定的浏览器\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226131423218.jpg)\r\n**4.jQuery Code Snippets**\r\n\r\n> 	jquery的插件\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226131800939.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**5.Auto Close Tag**\r\n	\r\n\r\n> 自动闭合标签\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226132114601.jpg)\r\n\r\n**6.Auto Rename Tag**\r\n\r\n> 修改标签时尾标签自动修改\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226132213229.jpg)\r\n**7.Eclipse Keymap**\r\n\r\n> 	这个是eclipse的一些快捷键，在vscode中可以使用。\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022613240165.jpg)\r\n**8.Add jsdoc comments**\r\n\r\n> 字面意思 ，关于注释插件（可选）\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226231413675.png)\r\n\r\n**9.Beautify**\r\n\r\n> 代码格式化插件\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226231607251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**10.Bracket Pair Colorizer**\r\n\r\n> 它为代码中的各种结对的括号兄弟们提供了颜色高亮\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226231821432.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**11.Class autocomplete for HTML\r\n提示html中class属性**![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226232224213.jpg)\r\n**12.Debugger for Chrome**\r\n	\r\n\r\n> vs中启动chrome控制台\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226232404580.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**13.ES7 React/Redux/GraphQL/React-Native snippets（可选）**\r\n\r\n> 	代码片段的简写\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226232838662.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n**14.ESLint**\r\n\r\n> javascript代码检测工具。\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226232949629.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**15.filesize**\r\n\r\n> 在编辑器的状态栏中显示聚焦文件的大小。(可选)\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226233154541.jpg)\r\n\r\n**16.HTML CSS Support（可选）**\r\n\r\n> html中css的class智能提示\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226233429816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**17.HTML Snippets**\r\n\r\n> html中使用 完整的HTML5标签 显色 片段\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226233553435.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**18.IntelliSense for CSS class names in HTML**\r\n\r\n> 使您可以自动完成在工作区中找到的CSS类定义（在CSS文件或“支持的语言模式”部分中列出的文件类型中定义）\r\n> 支持通过linkHTML文件中的元素引用的外部样式表 手动重新缓存自动完成中使用的类定义的命令\r\n> 用户设置以覆盖应在缓存过程中考虑或排除的文件夹和文件\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226233702765.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**19.JavaScript (ES6) code snippets**\r\n\r\n> js的插件es6的语法\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022623392755.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**20.JavaScript Snippet Pack**\r\n\r\n> 片段包 [cl] console.log\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226234119797.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**21.Path Intellisense**\r\n路径智能\r\n\r\n> 自动完成文件名的Visual Studio Code插件。\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226234254909.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**22.Prettier - Code formatter**\r\n\r\n> 代码格式化，这种插件很多，按照不同的格式去格式，找一个自己喜欢的就行了\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226234422271.jpg)\r\n\r\n**23.Vetur**\r\n\r\n> vue的插件，学js之后有兴趣学习vue可以去了解 语法高亮 片段 Emmet 整理/错误检查 格式化 自动完成 调试\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226234552357.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**24.Vue 2 Snippets**\r\n\r\n> 这个插件基于最新的Vue 2的API添加了代码段。 可以理解为代码片段\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022623471968.jpg)\r\n**25.Vue TypeScript Snippets**\r\n\r\n> VS Code的Vue / Vuex TypeScript代码片段 Visual Studio Code的此扩展为TypeScript和HTML添加了Vue / Vuex的代码片段。 使用扩展 用法\r\n> 输入一段代码的一部分，按enter，然后代码段将展开。\r\n\r\n\r\n\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226234931163.jpg)\r\n\r\n**26.VueHelper**\r\n\r\n> （1）可能是Vscode中最好的vue代码片段插件，不仅包含vue2所有api，还包含vue-router 2和vuex 2代码\r\n> （2）每个代码段都有详细的描述，主要是为了方便学习，因为当学习忘记使用api时，经常查阅文档会浪费时间，因此我将增加每个代码段的描述，说明根据官方文件得出\r\n> 	方式提示许多插件都是使用速记方式，例如，路由器对象方法，请输入rtb->will提示router.beforeEach()，这很方便，但是需要强迫您记住而不是友好。所以我所采取的是当您type\r\n> router，它列出了路由器对象的所有属性和方法\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226235130550.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xfeGlvYWJhaV9M,size_16,color_FFFFFF,t_70)\r\n\r\n**27 .v scode-icons**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606092122673.jpg)\r\n更改目录模样插件，改完安装之后的样子。\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606092310870.jpg)\r\n**28. Live Share**\r\n\r\n**这个是一起写代码的，就是别人可以和你一起在一个电脑上面写代码，远程操作写代码。**\r\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200606092433481.jpg)\r\n\r\n# 个人总结\r\n\r\n```cpp\r\n	插件安装+需求装，没必要都装，装多了可能会有冲突，但是可以解决。\r\n	想装需要的插件，建议去看官方文档或者其他的csdn，慢慢学习，加油！\r\n	如果懂vcode配置文件的话，可以自己去配置setting.json或者其他的json配置文件。\r\n	好了，其实入门js装几个基础插件就行了，其它插件装原因的主要是方便！可以不装！\r\n	新手小白刚刚入坑，如有错误，请勿见怪！\r\n```\r\n\r\n/*******************************************************************************************************/\r\n\r\n\r\n微信小程序插件：\r\n**1. 小程序开发助手**\r\n**2. minapp**\r\n**3. wechat-snippet**\r\n\r\n\r\n', '2019-10-21 06:02:12', '/images/timg.jpg', '原创', '', '\0', '\0', 'vscode 插件', '2020-06-24 06:02:12', '6', '1', '1', '3,4,5', 'vscode基本配置\nvs的基本配置\n\n\n1.适合于css，html，js\n\n\n\n1.下载vscode\n\n下载地址：https://c');
INSERT INTO `t_blog` VALUES ('1275671111467532288', '\0', '', '## redis入门开始 \r\n\r\n### 1.安装环境\r\n官网：https://redis.io/\r\n我已经下载好了\r\nredis-6.0.3.tar.gz\r\n\r\n我的下载目录为/opt下面 \r\n解压\r\n\r\n```bash\r\ntar -zxvf redis-6.0.3.tar.gz \r\n\r\nredis-6.0.3/utils/hyperloglog/hll-gnuplot-graph.rb\r\nredis-6.0.3/utils/install_server.sh\r\nredis-6.0.3/utils/lru/\r\nredis-6.0.3/utils/lru/README\r\nredis-6.0.3/utils/lru/lfu-simulation.c\r\nredis-6.0.3/utils/lru/test-lru.rb\r\nredis-6.0.3/utils/redis-copy.rb\r\nredis-6.0.3/utils/redis-sha1.rb\r\nredis-6.0.3/utils/redis_init_script\r\nredis-6.0.3/utils/redis_init_script.tpl\r\nredis-6.0.3/utils/releasetools/\r\n```\r\n安装依赖环境\r\n```bash\r\nyum install gcc-c++\r\n```\r\n查看环境安装\r\n```bash\r\ngcc -v\r\n```\r\n\r\n```bash\r\nmake 之后的\r\n[root@VM_0_11_centos redis-6.0.3]# make\r\ncd src && make all\r\nmake[1]: Entering directory `/home/A/redis-6.0.3/src\'\r\n\r\nHint: It\'s a good idea to run \'make test\' ;)\r\n\r\nmake[1]: Leaving directory `/home/A/redis-6.0.3/src\'\r\n[root@VM_0_11_centos redis-6.0.3]#\r\n[root@VM_0_11_centos redis-6.0.3]# make install\r\ncd src && make install\r\nmake[1]: Entering directory `/home/A/redis-6.0.3/src\'\r\n\r\nHint: It\'s a good idea to run \'make test\' ;)\r\n\r\n    INSTALL install\r\n    INSTALL install\r\n    INSTALL install\r\n    INSTALL install\r\n    INSTALL install\r\nmake[1]: Leaving directory `/home/A/redis-6.0.3/src\'\r\n[root@VM_0_11_centos redis-6.0.3]#\r\n\r\n```\r\n如果你make报错.原因可能是：\r\n如果你用的redis 6.0以上，那么你的gcc版本低\r\n解决办法：我的默认gcc应该是4.8.5 \r\n你可以选择升级一下\r\n原文：[升级gcc](https://blog.csdn.net/baidu_37313657/article/details/106027207)\r\n```bash\r\n使用scl升级gcc\r\n//安装scl源\r\nyum -y install centos-release-scl\r\n//升级\r\nyum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils\r\n//scl命令启用只是临时的，退出shell或重启就会恢复原系统gcc版本\r\nscl enable devtoolset-9 bash\r\n//长久使用gcc 升级版\r\necho \"source /opt/rh/devtoolset-9/enable\" >>/etc/profile\r\n```\r\n我此时的gcc版本\r\n```bash\r\n[root@VM_0_11_centos bin]# gcc -v\r\nUsing built-in specs.\r\nCOLLECT_GCC=gcc\r\nCOLLECT_LTO_WRAPPER=/opt/rh/devtoolset-9/root/usr/libexec/gcc/x86_64-redhat-linux/9/lto-wrapper\r\nTarget: x86_64-redhat-linux\r\nConfigured with: ../configure --enable-bootstrap --enable-languages=c,c++,fortran,lto --prefix=/opt/rh/devtoolset-9/root/usr --mandir=/opt/rh/devtoolset-9/root/usr/share/man --infodir=/opt/rh/devtoolset-9/root/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-shared --enable-threads=posix --enable-checking=release --enable-multilib --with-system-zlib --enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-linker-build-id --with-gcc-major-version-only --with-linker-hash-style=gnu --with-default-libstdcxx-abi=gcc4-compatible --enable-plugin --enable-initfini-array --with-isl=/builddir/build/BUILD/gcc-9.1.1-20190605/obj-x86_64-redhat-linux/isl-install --disable-libmpx --enable-gnu-indirect-function --with-tune=generic --with-arch_32=x86-64 --build=x86_64-redhat-linux\r\nThread model: posix\r\ngcc version 9.1.1 20190605 (Red Hat 9.1.1-2) (GCC)\r\n```\r\nredis的默认安装路径\r\n执行make install 你的目录应该是这样的\r\n```bash\r\n[root@VM_0_11_centos bin]# pwd\r\n/usr/local/bin\r\n[root@VM_0_11_centos bin]# ls\r\njemalloc-config   luajit        myredisfonfig    redis-cli\r\njemalloc.sh       luajit-2.0.4  redis-benchmark  redis-sentinel\r\njeprof            mcrypt        redis-check-aof  redis-server\r\nlibmcrypt-config  mdecrypt      redis-check-rdb\r\n[root@VM_0_11_centos bin]#\r\n```\r\n将安装好的配置文件复制到/usr/local/bin/myconfig目录下\r\n方便以后启动指定配置文件 目录名我叫myconfig\r\n\r\nredis默认不是后台启动的，我们将他改为后台启动\r\n我们将redis.conf 配置文件改为yes\r\n```bash\r\n# By default Redis does not run as a daemon. Use \'yes\' if you need it.\r\n# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.\r\ndaemonize yes\r\n```\r\n启动redis 服务 指定配置文件\r\n```bash\r\n[root@VM_0_11_centos bin]# redis-cli myconfig/redis.conf\r\n(error) ERR unknown command `myconfig/redis.conf`, with args beginning with:\r\n[root@VM_0_11_centos bin]# redis-server myconfig/redis.conf\r\n11234:C 25 May 2020 16:11:54.616 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n11234:C 25 May 2020 16:11:54.616 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=11234, just started\r\n11234:C 25 May 2020 16:11:54.616 # Configuration loaded\r\n```\r\n\r\n开始连接\r\n\r\n```bash\r\n[root@VM_0_11_centos bin]# redis-cli -h 127.0.0.1 -p 6379\r\n127.0.0.1:6379> ping\r\nPONG\r\n127.0.0.1:6379>\r\n测试连接成功\r\n```\r\n基础测试\r\n\r\n```bash\r\n127.0.0.1:6379> set a a\r\nOK\r\n127.0.0.1:6379> get a\r\n\"a\"\r\n127.0.0.1:6379> keys *\r\n1) \"a\"\r\n\r\n```\r\n查看redis服务是否启动成功\r\n\r\n```bash\r\n[root@VM_0_11_centos ~]# ps -ef |grep redis\r\nroot     11916  1981  0 16:16 pts/0    00:00:00 redis-cli -h 127.0.0.1 -p 6379\r\nroot     11923 11711  0 16:16 pts/1    00:00:00 grep --color=auto redis\r\nroot     32326     1  0 11:26 ?        00:00:25 redis-server 127.0.0.1:6379\r\n```\r\n\r\n\r\n关闭服务，退出连接·\r\n\r\n```bash\r\n[root@VM_0_11_centos bin]# redis-cli -h 127.0.0.1 -p 6379\r\n127.0.0.1:6379> shutdown\r\nnot connected> exit\r\n[root@VM_0_11_centos ~]# ps -ef |grep redis\r\nroot     12301 11711  0 16:19 pts/1    00:00:00 grep --color=auto redis\r\n\r\n```\r\n\r\n### 2.基本操作\r\n测试性能\r\nredis-benchmark工具\r\n100个连接，100000个请求 \r\n```bash\r\n[root@VM_0_11_centos bin]# redis-server myconfig/redis.conf\r\n12667:C 25 May 2020 16:21:55.241 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\r\n12667:C 25 May 2020 16:21:55.241 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=12667, just started\r\n12667:C 25 May 2020 16:21:55.241 # Configuration loaded\r\n[root@VM_0_11_centos bin]# redis-cli -h 127.0.0.1 -p 6379\r\n127.0.0.1:6379> exit\r\n[root@VM_0_11_centos bin]# redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000\r\n\r\n```\r\n\r\n```bash\r\n  100000 requests completed in 2.11 seconds\r\n  100 parallel clients\r\n  3 bytes payload\r\n  keep alive: 1\r\n  host configuration \"save\": 900 1 300 10 60 10000\r\n  host configuration \"appendonly\": no\r\n  multi-thread: no\r\n  \r\n在2.11秒内完成100000个请求\r\n   100个并行客户端\r\n   3字节有效载荷\r\n   保持生命：1\r\n   主机配置“保存”：900 1 300 10 60 10000\r\n   主机配置“ appendonly”：否\r\n   多线程：否\r\n```\r\n\r\n ==处理时间==  \r\n\r\n```bash\r\n 0.00% <= 0.8 milliseconds\r\n0.02% <= 0.9 milliseconds\r\n5.97% <= 1.0 milliseconds\r\n14.51% <= 1.1 milliseconds\r\n23.21% <= 1.2 milliseconds\r\n31.88% <= 1.3 milliseconds\r\n40.60% <= 1.4 milliseconds\r\n49.34% <= 1.5 milliseconds\r\n58.10% <= 1.6 milliseconds\r\n66.79% <= 1.7 milliseconds\r\n75.55% <= 1.8 milliseconds\r\n84.30% <= 1.9 milliseconds\r\n93.02% <= 2 milliseconds\r\n99.54% <= 3 milliseconds\r\n99.81% <= 4 milliseconds\r\n99.90% <= 5 milliseconds\r\n99.96% <= 6 milliseconds\r\n100.00% <= 6 milliseconds\r\n47393.37 requests per second\r\n```\r\n', '2020-04-24 06:04:28', 'https://iknow-pic.cdn.bcebos.com/37d3d539b6003af38a734cfd322ac65c1138b666', '原创', '', '', '', 'linux 安装redis 6.0', '2020-06-24 06:09:09', '8', '7', '1', '14', 'redis入门开始\n1.安装环境\n\n官网：https://redis.io/\n我已经下载好了\nredis-6.0.3.tar.gz\n\n\n我的下载目录为/opt下面\n解压');

-- ----------------------------
-- Table structure for t_blog_tags
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tags`;
CREATE TABLE `t_blog_tags` (
  `blogs_id` bigint(20) NOT NULL,
  `tags_id` bigint(20) NOT NULL,
  KEY `FK5feau0gb4lq47fdb03uboswm8` (`tags_id`),
  KEY `FKh4pacwjwofrugxa9hpwaxg6mr` (`blogs_id`),
  CONSTRAINT `t_blog_tags_ibfk_1` FOREIGN KEY (`blogs_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `t_blog_tags_ibfk_2` FOREIGN KEY (`tags_id`) REFERENCES `t_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_blog_tags
-- ----------------------------
INSERT INTO `t_blog_tags` VALUES ('1271646782887034880', '7');
INSERT INTO `t_blog_tags` VALUES ('1271646782887034880', '10');
INSERT INTO `t_blog_tags` VALUES ('1271646782887034880', '6');
INSERT INTO `t_blog_tags` VALUES ('1271646382477803520', '10');
INSERT INTO `t_blog_tags` VALUES ('1271646382477803520', '7');
INSERT INTO `t_blog_tags` VALUES ('1271646522898907136', '2');
INSERT INTO `t_blog_tags` VALUES ('1271646522898907136', '7');
INSERT INTO `t_blog_tags` VALUES ('1271647463249281024', '4');
INSERT INTO `t_blog_tags` VALUES ('1271647463249281024', '5');
INSERT INTO `t_blog_tags` VALUES ('1271647463249281024', '10');
INSERT INTO `t_blog_tags` VALUES ('1271647916540297216', '6');
INSERT INTO `t_blog_tags` VALUES ('1271647916540297216', '7');
INSERT INTO `t_blog_tags` VALUES ('1275670130210111488', '7');
INSERT INTO `t_blog_tags` VALUES ('1275670130210111488', '1');
INSERT INTO `t_blog_tags` VALUES ('1275670539167334400', '3');
INSERT INTO `t_blog_tags` VALUES ('1275670539167334400', '4');
INSERT INTO `t_blog_tags` VALUES ('1275670539167334400', '5');
INSERT INTO `t_blog_tags` VALUES ('1275671111467532288', '14');
INSERT INTO `t_blog_tags` VALUES ('1271647674415710208', '8');
INSERT INTO `t_blog_tags` VALUES ('1271647674415710208', '7');
INSERT INTO `t_blog_tags` VALUES ('1271647674415710208', '6');
INSERT INTO `t_blog_tags` VALUES ('1271647674415710208', '10');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin_comment` bit(1) DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '默认头像',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `create_time` datetime(6) DEFAULT NULL COMMENT '创建时间',
  `email` varchar(255) DEFAULT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论名字',
  `blog_id` bigint(20) DEFAULT NULL COMMENT '博客id',
  `parent_conmment_id` bigint(20) DEFAULT NULL COMMENT '父id',
  PRIMARY KEY (`id`),
  KEY `FKke3uogd04j4jx316m1p51e05u` (`blog_id`),
  KEY `FKpxijih6x1g2w0f035y5nwl20p` (`parent_conmment_id`),
  CONSTRAINT `t_comment_ibfk_1` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES ('6', '\0', '/images/xiaolian.jpg', '我是测试', '2020-06-26 15:11:58.767000', '123@qq.com', '游客1', '1275670130210111488', '-1');
INSERT INTO `t_comment` VALUES ('7', '\0', '/images/xiaolian.jpg', '我还是测试', '2020-06-26 15:12:33.821000', '123@qq.com', '游客2', '1275670130210111488', '-1');
INSERT INTO `t_comment` VALUES ('8', '\0', '/images/xiaolian.jpg', '我是测试', '2020-06-26 15:12:37.664000', '123@qq.com', '游客3', '1275670130210111488', '-1');
INSERT INTO `t_comment` VALUES ('9', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '我是博主', '2020-06-26 15:30:29.762000', '11.@qq.com', '小白', '1275670130210111488', '6');
INSERT INTO `t_comment` VALUES ('10', '\0', '/images/xiaolian.jpg', '我是测试二级的', '2020-06-26 15:38:28.718000', '123@qq.com', '游客', '1275670130210111488', '6');
INSERT INTO `t_comment` VALUES ('11', '\0', '/images/xiaolian.jpg', '我是测试二级的', '2020-06-26 16:31:40.937000', '123@qq.com', '游客', '1275670130210111488', '7');
INSERT INTO `t_comment` VALUES ('12', '\0', '/images/xiaolian.jpg', '哈哈我是测试的第一个', '2020-06-26 16:38:20.258000', '123@qq.com', '游客', '1271647916540297216', '-1');
INSERT INTO `t_comment` VALUES ('13', '\0', '/images/xiaolian.jpg', '我是测试二级的', '2020-06-26 16:38:31.631000', '123@qq.com', '游客', '1271647916540297216', '12');
INSERT INTO `t_comment` VALUES ('14', '\0', '/images/xiaolian.jpg', '在测试一下', '2020-06-26 16:38:45.004000', '123@qq.com', '游客', '1271647916540297216', '12');
INSERT INTO `t_comment` VALUES ('15', '\0', '/images/xiaolian.jpg', 'hellow', '2020-06-26 16:39:25.536000', '123@qq.com', '游客', '1275670130210111488', '-1');
INSERT INTO `t_comment` VALUES ('16', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '我是博主', '2020-06-26 16:43:33.529000', '11.@qq.com', '小白', '1275670130210111488', '15');
INSERT INTO `t_comment` VALUES ('17', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '我是博主，你知道吗？', '2020-06-26 16:43:53.328000', '11.@qq.com', '小白', '1275670130210111488', '-1');
INSERT INTO `t_comment` VALUES ('18', '\0', '/images/xiaolian.jpg', '测试留言', '2020-06-26 16:50:01.293000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('19', '\0', '/images/xiaolian.jpg', '11', '2020-06-26 16:52:13.092000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('20', '\0', '/images/xiaolian.jpg', '1', '2020-06-26 16:53:11.388000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('21', '\0', '/images/xiaolian.jpg', '111', '2020-06-26 16:54:19.568000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('22', '\0', '/images/xiaolian.jpg', '222', '2020-06-26 16:56:15.958000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('23', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '我是博主\n', '2020-06-26 16:56:52.985000', '11.@qq.com', '小白', '1271647463249281024', '18');
INSERT INTO `t_comment` VALUES ('24', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '你不能太皮晓得吗', '2020-06-26 16:57:09.548000', '11.@qq.com', '小白', '1271647463249281024', '19');
INSERT INTO `t_comment` VALUES ('25', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '博主发言了', '2020-06-26 16:58:26.895000', '11.@qq.com', '小白', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('26', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '测试恢复博主', '2020-06-26 16:58:36.608000', '11.@qq.com', '小白', '1271647463249281024', '25');
INSERT INTO `t_comment` VALUES ('27', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '啦啦啦', '2020-06-26 17:06:27.678000', '11.@qq.com', '小白不爱说话', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('28', '\0', '/images/xiaolian.jpg', '哈哈 我该名字了', '2020-06-26 17:07:35.273000', '123@qq.com', '游客', '1271647463249281024', '27');
INSERT INTO `t_comment` VALUES ('29', '\0', '/images/xiaolian.jpg', '第一个测试', '2020-06-26 17:08:08.728000', '123@qq.com', '游客', '1275671111467532288', '-1');
INSERT INTO `t_comment` VALUES ('30', '\0', '/images/xiaolian.jpg', '打包前的测试', '2020-06-27 01:12:58.147000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('31', '\0', '/images/xiaolian.jpg', '测试啊', '2020-06-27 01:13:07.253000', '123@qq.com', '游客', '1271647463249281024', '30');
INSERT INTO `t_comment` VALUES ('32', '\0', '/images/xiaolian.jpg', '啊啊啊', '2020-06-27 01:17:10.945000', '123@qq.com', '游客', '1271647463249281024', '-1');
INSERT INTO `t_comment` VALUES ('33', '\0', '/images/xiaolian.jpg', '测试', '2020-06-27 03:10:35.063000', '123@qq.com', '游客', '1275670539167334400', '-1');
INSERT INTO `t_comment` VALUES ('34', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '1111', '2020-06-27 07:54:54.037000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '-1');
INSERT INTO `t_comment` VALUES ('35', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 07:55:04.738000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '-1');
INSERT INTO `t_comment` VALUES ('36', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '2222', '2020-06-27 07:57:04.999000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '-1');
INSERT INTO `t_comment` VALUES ('37', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '11111', '2020-06-27 07:58:01.220000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '36');
INSERT INTO `t_comment` VALUES ('38', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '1111', '2020-06-27 07:58:04.350000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '-1');
INSERT INTO `t_comment` VALUES ('39', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', 'fsdfsdfdFsdf', '2020-06-27 07:58:07.776000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '-1');
INSERT INTO `t_comment` VALUES ('40', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '333333', '2020-06-27 07:58:13.215000', '11.@qq.com', '小白不爱说话', '1271646382477803520', '36');
INSERT INTO `t_comment` VALUES ('41', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '33333', '2020-06-27 07:58:23.861000', '11.@qq.com', '小白不爱说话', '1271647674415710208', '-1');
INSERT INTO `t_comment` VALUES ('42', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '2222', '2020-06-27 07:58:27.242000', '11.@qq.com', '小白不爱说话', '1271647674415710208', '41');
INSERT INTO `t_comment` VALUES ('43', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '11111', '2020-06-27 07:58:31.427000', '11.@qq.com', '小白不爱说话', '1271647674415710208', '41');
INSERT INTO `t_comment` VALUES ('44', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 08:09:20.542000', '11.@qq.com', '小白不爱说话', '1271647674415710208', '-1');
INSERT INTO `t_comment` VALUES ('45', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '2222', '2020-06-27 08:09:42.736000', '11.@qq.com', '小白不爱说话', '1271647674415710208', '44');
INSERT INTO `t_comment` VALUES ('46', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 08:10:00.294000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '29');
INSERT INTO `t_comment` VALUES ('47', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '1111', '2020-06-27 08:10:07.066000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '29');
INSERT INTO `t_comment` VALUES ('48', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 08:10:33.836000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '-1');
INSERT INTO `t_comment` VALUES ('49', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '1111', '2020-06-27 08:10:39.328000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '-1');
INSERT INTO `t_comment` VALUES ('50', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 08:10:42.362000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '-1');
INSERT INTO `t_comment` VALUES ('51', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 08:10:46.542000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '-1');
INSERT INTO `t_comment` VALUES ('52', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '1', '2020-06-27 08:11:26.715000', '11.@qq.com', '小白不爱说话', '1275671111467532288', '51');
INSERT INTO `t_comment` VALUES ('53', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '1111', '2020-06-27 08:23:15.969000', '11.@qq.com', '小白不爱说话', '1275670130210111488', '6');
INSERT INTO `t_comment` VALUES ('54', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '111', '2020-06-27 08:23:22.688000', '11.@qq.com', '小白不爱说话', '1275670130210111488', '-1');

-- ----------------------------
-- Table structure for t_leave_comments
-- ----------------------------
DROP TABLE IF EXISTS `t_leave_comments`;
CREATE TABLE `t_leave_comments` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `admin_comment` bit(1) DEFAULT NULL,
  `avatar` varchar(200) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `name` varchar(100) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_leave_comments
-- ----------------------------
INSERT INTO `t_leave_comments` VALUES ('6', '', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '我是博主', '2020-06-27 08:51:30', '小白不爱说话', '11.@qq.com');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=32 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES ('1', 'java');
INSERT INTO `t_tag` VALUES ('2', 'mysql');
INSERT INTO `t_tag` VALUES ('3', 'css');
INSERT INTO `t_tag` VALUES ('4', 'html');
INSERT INTO `t_tag` VALUES ('5', 'js');
INSERT INTO `t_tag` VALUES ('6', 'spring');
INSERT INTO `t_tag` VALUES ('7', 'mybatis');
INSERT INTO `t_tag` VALUES ('8', 'springmvc');
INSERT INTO `t_tag` VALUES ('10', 'redis');
INSERT INTO `t_tag` VALUES ('12', '其它');
INSERT INTO `t_tag` VALUES ('13', '工具');
INSERT INTO `t_tag` VALUES ('14', 'linux');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES ('1', '前端');
INSERT INTO `t_type` VALUES ('3', '后端');
INSERT INTO `t_type` VALUES ('4', '大数据');
INSERT INTO `t_type` VALUES ('6', '数据库');
INSERT INTO `t_type` VALUES ('7', '运维');
INSERT INTO `t_type` VALUES ('9', '其它');
INSERT INTO `t_type` VALUES ('10', '工具');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `type` int(11) DEFAULT NULL,
  `update_time` datetime DEFAULT NULL,
  `username` varchar(255) DEFAULT NULL,
  `nickname` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES ('1', 'http://gss0.baidu.com/7Po3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/dcc451da81cb39db71c95924d8160924ab1830b2.jpg', '2020-04-25 21:58:51', '11.@qq.com', 'c4ca4238a0b923820dcc509a6f75849b', '1', '2020-04-25 21:59:22', '1', '小白不爱说话');
